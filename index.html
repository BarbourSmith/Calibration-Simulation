<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maslow CNC Calibration Simulation</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            padding: 30px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }
        
        h1 {
            margin: 0 0 10px 0;
            color: #2d3748;
            font-size: 32px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #718096;
            font-size: 16px;
            margin: 0;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .section h3 {
            margin: 0 0 15px 0;
            color: #2d3748;
            font-size: 18px;
            font-weight: 600;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #4a5568;
            font-weight: 500;
            font-size: 14px;
        }
        
        textarea, input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            transition: border-color 0.3s ease;
        }
        
        textarea:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        textarea {
            resize: vertical;
        }
        
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .input-field {
            display: flex;
            flex-direction: column;
        }
        
        .status-message {
            margin-left: 10px;
            font-weight: 600;
            font-size: 14px;
        }
        
        #surface-map-canvas {
            border: 2px solid #e2e8f0;
            margin: 20px 0;
            cursor: move;
            border-radius: 8px;
            display: block;
            max-width: 100%;
        }
        
        #search-info {
            margin: 20px 0;
            font-family: monospace;
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #48bb78;
        }
        
        #search-info h3 {
            margin-top: 0;
            color: #2d3748;
        }
        
        #CursorLayer {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            display: block;
            margin: 20px 0;
            max-width: 100%;
        }
        
        #output {
            font-family: 'Courier New', monospace;
            background: #1a202c;
            color: #48bb78;
            border: none;
            border-radius: 8px;
            padding: 15px;
        }
    </style>
</head>
<body id="mainBody">
    <div class="container">
        <header>
            <h1>Maslow CNC Calibration Simulation</h1>
            <p class="subtitle">Optimize your machine's anchor point positions using measurement data</p>
        </header>
        <div class="section">
            <h3>Calibration Data Input</h3>
            <label for="calibration-input">Paste your measurement data below:</label>
            <textarea id="calibration-input" rows="6" placeholder="Paste calibration data like: {bl:1942.31, br:1952.85, tr:2053.05, tl:2051.76},{bl:2132.14, br:1584.18, tr:1955.15, tl:2154.52},..."></textarea>
            <div class="button-group" style="margin-top: 10px;">
                <button id="parse-data-button">Parse Calibration Data</button>
                <span id="parse-status" class="status-message"></span>
            </div>
        </div>

        <div class="section">
            <h3>Initial Anchor Point Positions</h3>
            <div class="input-grid">
                <div class="input-field">
                    <label for="tlx-input">Top Left X (mm)</label>
                    <input type="number" id="tlx-input" value="0" step="0.1">
                </div>
                <div class="input-field">
                    <label for="tly-input">Top Left Y (mm)</label>
                    <input type="number" id="tly-input" value="2500" step="0.1">
                </div>
                <div class="input-field">
                    <label for="trx-input">Top Right X (mm)</label>
                    <input type="number" id="trx-input" value="3600" step="0.1">
                </div>
                <div class="input-field">
                    <label for="try-input">Top Right Y (mm)</label>
                    <input type="number" id="try-input" value="2500" step="0.1">
                </div>
                <div class="input-field">
                    <label for="brx-input">Bottom Right X (mm)</label>
                    <input type="number" id="brx-input" value="3600" step="0.1">
                </div>
            </div>
            <div class="button-group">
                <button id="apply-anchor-button">Apply Positions</button>
                <button id="randomize-anchor-button">Randomize Positions</button>
                <span id="anchor-status" class="status-message"></span>
            </div>
        </div>

        <div class="section">
            <h3>Measurement Adjustments</h3>
            <div class="input-grid">
                <div class="input-field">
                    <label for="scale-input">Scale Factor</label>
                    <input type="number" id="scale-input" value="1.0" step="0.0001" min="0.001">
                </div>
                <div class="input-field">
                    <label for="offset-input">Offset (mm)</label>
                    <input type="number" id="offset-input" value="0" step="0.1">
                </div>
            </div>
            <div class="button-group">
                <button id="apply-adjustments-button">Apply Adjustments</button>
                <span id="adjustments-status" class="status-message"></span>
            </div>
        </div>

        <div class="section">
            <h3>Optimization Controls</h3>
            <div style="margin-bottom: 15px;">
                <label style="display: inline-flex; align-items: center; cursor: pointer; font-weight: 500;">
                    <input type="checkbox" id="use-rectangular-approximation" checked style="margin-right: 8px; cursor: pointer; width: auto;">
                    Use rectangular approximation for poor initial guesses (fitness < 0.1)
                </label>
            </div>
            <div class="button-group">
                <button id="compute-button">Refine Measurements 1x</button>
                <button id="compute-converge-button">Converge</button>
            </div>
        </div>
        <div id="views"></div>
        
        <div id="search-info" style="display:none;">
            <h3>Search Space Visualization - Interactive 3D Surface Map</h3>
            <p id="search-status">Preparing search...</p>
        </div>
        
        <canvas id="surface-map-canvas" width="1000" height="600" style="display:none;"></canvas>
        
        <div class="section">
            <h3>Output</h3>
            <textarea id="output" rows="16" readonly></textarea>
        </div>
    </div>



<script>

// Z-heights for belt anchor points (used in projection calculations)
var tlZ = 100
var trZ = 56
var blZ = 34
var brZ = 78
var acceptableCalibrationThreshold = 0.5

// Maximum number of low-fitness retry attempts before giving up
const MAX_LOW_FITNESS_RETRIES = 10;

//This is the inital guess for how big the machine is. These numbers are wrong intensionally
const initialWidth = 3048 + 12;
const initialHeight = 2200 - 14;


//These are the true corners of the machine that we want to solve for (only used for simulated measurments)
const trueTLX = -0.6948090610228441;
const trueTLY = 2131.275233532367;
const trueTRX = 3034.4072793128926;
const trueTRY = 2127.1780972406527;
const trueBLX = 0;
const trueBLY = 0;
const trueBRX = 3034.960970894897;
const trueBRY = 0;


/**------------------------------------Intro------------------------------------
*
*   If you are reading this code to understand it then I would recommend starting
*  at the bottom of the page and working your way up. The code is written in a
* functional style so the function definitions are at the top and the code that
* actually runs is at the bottom. It was also written quickly and modified a lot
* so it is not very clean. I apologize for that.
*
*------------------------------------------------------------------------------
*/


/**
 * Simulates a measurement at a given location with random and constant errors.
 * @param {number} x - The x-coordinate of the location to measure.
 * @param {number} y - The y-coordinate of the location to measure.
 * @param {number} randomError - The maximum amount of random error to add to the measurement.
 * @param {number} constantError - The constant error to add to the measurement.
 * @returns {Object} - An object containing the simulated measurements at the given location.
 */
function takeSimulatedMeasurement(x,y,randomError, constantError){
    const tl = distanceBetweenPoints(trueTLX, trueTLY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const tr = distanceBetweenPoints(trueTRX, trueTRY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const bl = distanceBetweenPoints(trueBLX, trueBLY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const br = distanceBetweenPoints(trueBRX, trueBRY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    return {tl: tl, tr: tr, bl: bl, br: br};
}

/**
 * Computes the distance between two points.
 * @param {number} a - The x-coordinate of the first point.
 * @param {number} b - The y-coordinate of the first point.
 * @param {number} c - The x-coordinate of the second point.
 * @param {number} d - The y-coordinate of the second point.
 * @returns {number} - The distance between the two points.
 */
function distanceBetweenPoints(a, b, c, d) {
  var dx = c - a;
  var dy = d - b;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Computes the end point of a line based on its starting point, angle, and length.
 * @param {number} startX - The x-coordinate of the line's starting point.
 * @param {number} startY - The y-coordinate of the line's starting point.
 * @param {number} angle - The angle of the line in radians.
 * @param {number} length - The length of the line.
 * @returns {Object} - An object containing the x and y coordinates of the line's end point.
 */
function getEndPoint(startX, startY, angle, length) {
  var endX = startX + length * Math.cos(angle);
  var endY = startY + length * Math.sin(angle);
  return { x: endX, y: endY };
}

/**
 * Computes how close all of the line end points are to each other.
 * @param {Object} line1 - The first line to compare.
 * @param {Object} line2 - The second line to compare.
 * @param {Object} line3 - The third line to compare.
 * @param {Object} line4 - The fourth line to compare.
 * @returns {number} - The fitness value, which is the average distance between all line end points.
 */
function computeEndpointFitness(line1, line2, line3, line4){

    const a = distanceBetweenPoints(line1.xEnd, line1.yEnd, line2.xEnd, line2.yEnd);
    const b = distanceBetweenPoints(line1.xEnd, line1.yEnd, line3.xEnd, line3.yEnd);
    const c = distanceBetweenPoints(line1.xEnd, line1.yEnd, line4.xEnd, line4.yEnd);
    const d = distanceBetweenPoints(line2.xEnd, line2.yEnd, line3.xEnd, line3.yEnd);
    const e = distanceBetweenPoints(line2.xEnd, line2.yEnd, line4.xEnd, line4.yEnd);
    const f = distanceBetweenPoints(line3.xEnd, line3.yEnd, line4.xEnd, line4.yEnd);

    const fitness = (a+b+c+d+e+f)/6;
    
    // Ensure fitness is never exactly 0 to prevent division by zero when displaying as 1/fitness
    // A fitness of 0 indicates a degenerate solution where all lines converge to a single point
    // Adding a small epsilon (0.001mm average error) prevents Infinity in the UI
    const MIN_FITNESS = 0.001;
    return Math.max(fitness, MIN_FITNESS);
}


/**
 * Computes the end point of a line based on its starting point, angle, and length.
 * @param {Object} line - The line to compute the end point for.
 * @returns {Object} - The line with the end point added.
 */
function computeLineEndPoint(line){
    const end = getEndPoint(line.xBegin, line.yBegin, line.theta, line.length);
    line.xEnd = end.x;
    line.yEnd = end.y;
    return line;
}

/**
 * Walks the four lines in the given set, adjusting their endpoints to minimize the distance between them.
 * @param {Object} tlLine - The top-left line in the set.
 * @param {Object} trLine - The top-right line in the set.
 * @param {Object} blLine - The bottom-left line in the set.
 * @param {Object} brLine - The bottom-right line in the set.
 * @param {number} stepSize - The amount to adjust the angle of each line by on each iteration.
 * @returns {Object} - An object containing the final positions of each line.
 */
function walkLines(tlLine, trLine, blLine, brLine, stepSize) {
  let changeMade = true;
  let bestFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);

  while (changeMade) {
    changeMade = false;

    const lines = [tlLine, trLine, blLine, brLine];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      for (let direction of [-1, 1]) {
        const newLine = computeLineEndPoint({
          xBegin: line.xBegin,
          yBegin: line.yBegin,
          theta: line.theta + direction * stepSize,
          length: line.length
        });

        const newFitness = computeEndpointFitness(
          i === 0 ? newLine : tlLine,
          i === 1 ? newLine : trLine,
          i === 2 ? newLine : blLine,
          i === 3 ? newLine : brLine
        );

        if (newFitness < bestFitness) {
          lines[i] = newLine;
          bestFitness = newFitness;
          changeMade = true;
        }
      }
    }

    tlLine = lines[0];
    trLine = lines[1];
    blLine = lines[2];
    brLine = lines[3];
  }

  const result = { tlLine, trLine, blLine, brLine, changeMade };

  sendCalibrationEvent({
    walkedlines: result,
  });

  return result;
}

/**
 * Computes the fitness of a set of lines based on how close their endpoints are to each other.
 * @param {Object} measurement - An object containing the initial theta values and lengths for each line.
 * @param {Object} individual - An object containing the x and y coordinates for each line's starting point.
 * @returns {Object} - An object containing the fitness value and the final positions of each line.
 */
function magneticallyAttractedLinesFitness(measurement, individual, skipDrawing = false){

    // Compute the center of the frame to get better initial theta values
    const centerX = (individual.tl.x + individual.tr.x + individual.bl.x + individual.br.x) / 4;
    const centerY = (individual.tl.y + individual.tr.y + individual.bl.y + individual.br.y) / 4;

    //These set the initial conditions for theta. They should point roughly toward the center of the frame.
    if(typeof measurement.tlTheta === 'undefined'){
        // Point from top-left corner toward center
        measurement.tlTheta = Math.atan2(centerY - individual.tl.y, centerX - individual.tl.x);
    }
    if(typeof measurement.trTheta === 'undefined'){
        // Point from top-right corner toward center
        measurement.trTheta = Math.atan2(centerY - individual.tr.y, centerX - individual.tr.x);
    }
    if(typeof measurement.blTheta === 'undefined'){
        // Point from bottom-left corner toward center
        measurement.blTheta = Math.atan2(centerY - individual.bl.y, centerX - individual.bl.x);
    }
    if(typeof measurement.brTheta === 'undefined'){
        // Point from bottom-right corner toward center
        measurement.brTheta = Math.atan2(centerY - individual.br.y, centerX - individual.br.x);
    }


    //Define the four lines with starting points and lengths
    var tlLine = computeLineEndPoint({xBegin: individual.tl.x, yBegin: individual.tl.y, theta: measurement.tlTheta, length: measurement.tl});
    var trLine = computeLineEndPoint({xBegin: individual.tr.x, yBegin: individual.tr.y, theta: measurement.trTheta, length: measurement.tr});
    var blLine = computeLineEndPoint({xBegin: individual.bl.x, yBegin: individual.bl.y, theta: measurement.blTheta, length: measurement.bl});
    var brLine = computeLineEndPoint({xBegin: individual.br.x, yBegin: individual.br.y, theta: measurement.brTheta, length: measurement.br});

    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .1);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .01);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .0001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .00001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .000001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .0000001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .00000001);

    measurement.tlTheta = tlLine.theta;
    measurement.trTheta = trLine.theta;
    measurement.blTheta = blLine.theta;
    measurement.brTheta = brLine.theta;

    //Compute the final fitness
    const finalFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);

    //Compute the tension in the two upper belts
    const { TL, TR } = calculateTensions(tlLine.xEnd, tlLine.yEnd, individual);
    measurement.TLtension = TL;
    measurement.TRtension = TR;

    if (!skipDrawing) {
        drawLines(tlLine, trLine, blLine, brLine, individual);
    }

    if (!skipDrawing) {
        sendCalibrationEvent({
          finalFitness,
          tensions: { TL, TR }
        });
    }

    return {fitness: finalFitness, lines: {tlLine: tlLine, trLine: trLine, blLine: blLine, brLine: brLine}};
}

/**
 * Computes the distance of one line's end point from the center of mass of the other three lines.
 * @param {Object} lineToCompare - The line to compute the distance for.
 * @param {Object} line2 - The second line to use in computing the center of mass.
 * @param {Object} line3 - The third line to use in computing the center of mass.
 * @param {Object} line4 - The fourth line to use in computing the center of mass.
 * @returns {Object} - An object containing the x and y distances from the center of mass.
 */
function computeDistanceFromCenterOfMass(lineToCompare, line2, line3, line4){

    //Compute the center of mass
    const x = (line2.xEnd + line3.xEnd + line4.xEnd)/3;
    const y = (line2.yEnd + line3.yEnd + line4.yEnd)/3;

    return {x: lineToCompare.xEnd - x, y: lineToCompare.yEnd - y};
}

/**
 * Computes the distances from the center of mass for four lines and converts them into the relevant variables that we can tweak.
 * @param {Object} lines - An object containing four lines to compute the distances from the center of mass for.
 * @returns {Object} - An object containing the distances from the center of mass for tlX, tlY, trX, trY, and brX.
 */
function generateTweaks(lines){
    //We care about the distances for tlX, tlY, trX, trY, brX

    const tlX = computeDistanceFromCenterOfMass(lines.tlLine, lines.trLine, lines.blLine, lines.brLine).x;
    const tlY = computeDistanceFromCenterOfMass(lines.tlLine, lines.trLine, lines.blLine, lines.brLine).y;
    const trX = computeDistanceFromCenterOfMass(lines.trLine, lines.tlLine, lines.blLine, lines.brLine).x;
    const trY = computeDistanceFromCenterOfMass(lines.trLine, lines.tlLine, lines.blLine, lines.brLine).y;
    const brX = computeDistanceFromCenterOfMass(lines.brLine, lines.tlLine, lines.trLine, lines.blLine).x;

    return {tlX: tlX, tly: tlY, trX: trX, trY: trY, brX: brX};
}

/**
 * Computes all of the tweaks and summarizes them to move the guess furthest from the center of mass of the lines.
 * @param {Array} lines - An array of lines to compute the tweaks for.
 * @param {Object} lastGuess - The last guess made by the algorithm.
 * @returns {Object} - The updated guess with the furthest tweaks applied.
 */
function computeFurthestFromCenterOfMass(lines, lastGuess){

    var tlX = 0;
    var tlY = 0;
    var trX = 0;
    var trY = 0;
    var brX = 0;

    //In total how far is each corner from the center of mass of each measurement
    lines.forEach(line => {
        const tweaks = generateTweaks(line);
        
        tlX = tlX + tweaks.tlX;
        tlY = tlY + tweaks.tly;
        trX = trX + tweaks.trX;
        trY = trY + tweaks.trY;
        brX = brX + tweaks.brX;

    })

    //Divide by the number of measurements to get the average
    tlX = tlX/lines.length;
    tlY = tlY/lines.length;
    trX = trX/lines.length;
    trY = trY/lines.length;
    brX = brX/lines.length;

    //Find which corner is the furthest off and is it in X or Y
    const maxError = Math.max(
        Math.abs(tlX),
        Math.abs(tlY),
        Math.abs(trX),
        Math.abs(trY),
        Math.abs(brX)
    );


    //Move the corner that is the furthest off in the direction needed
    var scalor = -1;
    if(maxError == Math.abs(tlX)){
        //console.log("Move tlY by: " + tlY/divisor);
        lastGuess.tl.x = lastGuess.tl.x + tlX*scalor;
    }
    if(maxError == Math.abs(tlY)){
        //console.log("Move tlY by: " + tlY/divisor);
        lastGuess.tl.y = lastGuess.tl.y + tlY*scalor;
    }
    else if(maxError == Math.abs(trX)){
        //console.log("Move trX by: " + trX/divisor);
        lastGuess.tr.x = lastGuess.tr.x + trX*scalor;
    }
    else if(maxError == Math.abs(trY)){
        //console.log("Move trY by: " + trY/divisor);
        lastGuess.tr.y = lastGuess.tr.y + trY*scalor;
    }
    else if(maxError == Math.abs(brX)){
        //console.log("Move brX by: " + brX/divisor);
        lastGuess.br.x = lastGuess.br.x + brX*scalor;
    }
    
    return lastGuess;
}

/**
 * Computes the fitness of a guess for a set of measurements by comparing the guess to magnetically attracted lines.
 * @param {Array} measurements - An array of measurements to compare the guess to.
 * @param {Object} lastGuess - The last guess made by the algorithm.
 * @returns {Object} - An object containing the fitness of the guess and the lines used to calculate the fitness.
 */
function computeLinesFitness(measurements, lastGuess, skipDrawing = false){
    var fitnesses = [];
    var allLines = [];
    
    //Check each of the measurements against the guess
    measurements.forEach(measurement => {
        const {fitness, lines} = magneticallyAttractedLinesFitness(measurement, lastGuess, skipDrawing);
        fitnesses.push(fitness);
        allLines.push(lines);
    });
    
    //Computes the average fitness of all of the measurements
    const fitness = calculateAverage(fitnesses);

    //Here is where we need to do the calculation of which corner is the worst and which direction to move it
    lastGuess = computeFurthestFromCenterOfMass(allLines, lastGuess);
    
    // Ensure fitness is never exactly 0 to prevent division by zero when displaying as 1/fitness
    const MIN_FITNESS = 0.001;
    lastGuess.fitness = Math.max(fitness, MIN_FITNESS);

    return lastGuess;
}



function calculateTensions(x, y, guess) {
    let Xtl = guess.tl.x;
    let Ytl = guess.tl.y;
    let Xtr = guess.tr.x;
    let Ytr = guess.tr.y;
    let Xbl = guess.bl.x;
    let Ybl = guess.bl.y;
    let Xbr = guess.br.x;
    let Ybr = guess.br.y;

    let mass = 5.0;
    const G_CONSTANT = 9.80665;
    let alpha = 0.26;
    let TL, TR;
  
    let A, C, sinD, cosD, sinE, cosE;
    let Fx, Fy;

    A = (Xtl - x) / (Ytl - y);
    C = (Xtr - x) / (Ytr - y);
    A = Math.abs(A);
    C = Math.abs(C);
    sinD = x / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    cosD = y / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    sinE = Math.abs(Xbr - x) / Math.sqrt(Math.pow(Xbr - x, 2) + Math.pow(y, 2));
    cosE = y / Math.sqrt(Math.pow(Xbr - x, 2) + Math.pow(y, 2));

    Fx = Ybr * sinE - Ybl * sinD;
    Fy = Ybr * cosE + Ybl * cosD + mass * G_CONSTANT * Math.cos(alpha);
    // console.log(`Fx = ${Fx.toFixed(1)}, Fy = ${Fy.toFixed(1)}`);

    let TLy = (Fx + C * Fy) / (A + C);
    let TRy = Fy - TLy;
    let TRx = C * (Fy - TLy);
    let TLx = A * TLy;

    // console.log(`TLy = ${TLy.toFixed(1)}, TRy = ${TRy.toFixed(1)}, TRx = ${TRx.toFixed(1)}, TLx = ${TLx.toFixed(1)}`);

    TL = Math.sqrt(Math.pow(TLx, 2) + Math.pow(TLy, 2));
    TR = Math.sqrt(Math.pow(TRx, 2) + Math.pow(TRy, 2));

    return { TL, TR };
}

/**
 * Flips the y-coordinate of a point to account for the canvas having y at the top.
 * @param {number} y - The y-coordinate to flip.
 * @returns {number} - The flipped y-coordinate.
 */
function flipY(y) {
  var canvas = document.getElementById("CursorLayer");
  return canvas.height - y;
}

function changeStrokeStyle(inputValue) {
  const green = [0, 128, 0]; // RGB values for green
  const red = [255, 0, 0]; // RGB values for red
  const range = 60 - 20; // Range of input values
  const increment = (red.map((value, index) => value - green[index])).map(value => value / range); // Increment for each RGB value

  const color = green.map((value, index) => Math.round(value + increment[index] * (inputValue - 20))); // Calculate the color based on the input value

  const canvas = document.getElementById("CursorLayer");
  const ctx = canvas.getContext("2d");

  ctx.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`; // Set the strokeStyle to the calculated color
}

/**
 * Draws four lines on a canvas element and adds a circle at the end of each line.
 * @param {Object} line1 - An object containing the x and y coordinates of the beginning and end of the first line.
 * @param {Object} line2 - An object containing the x and y coordinates of the beginning and end of the second line.
 * @param {Object} line3 - An object containing the x and y coordinates of the beginning and end of the third line.
 * @param {Object} line4 - An object containing the x and y coordinates of the beginning and end of the fourth line.
 * @returns {void}
 */
function drawLines(line1, line2, line3, line4, guess) {

    //Compute the tensions in the upper two belts
    //const { TL, TR } = calculateTensions(line1.xEnd, line1.yEnd, guess); //This assumes the ends are in the same place which they aren't at first

    var canvas = document.getElementById("CursorLayer");
    var ctx = canvas.getContext("2d");

    // Set the stroke color to a lighter grey
    ctx.strokeStyle = "#999";

    // Draw the four lines
    ctx.setLineDash([5, 5]);

    //Top left line
    ctx.beginPath();
    ctx.moveTo(line1.xBegin / 4, flipY(line1.yBegin / 4));
    ctx.lineTo(line1.xEnd / 4, flipY(line1.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line1.xEnd / 4, flipY(line1.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    //Top right line
    ctx.beginPath();
    ctx.moveTo(line2.xBegin / 4, flipY(line2.yBegin / 4));
    ctx.lineTo(line2.xEnd / 4, flipY(line2.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line2.xEnd / 4, flipY(line2.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line3.xBegin / 4, flipY(line3.yBegin / 4));
    ctx.lineTo(line3.xEnd / 4, flipY(line3.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line3.xEnd / 4, flipY(line3.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line4.xBegin / 4, flipY(line4.yBegin / 4));
    ctx.lineTo(line4.xEnd / 4, flipY(line4.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line4.xEnd / 4, flipY(line4.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();
}



/**
 * Calculates the average of an array of numbers.
 * @param {number[]} array - The array of numbers to calculate the average of.
 * @returns {number} - The average of the array.
 */
function calculateAverage(array) {
    var total = 0;
    var count = 0;

    array.forEach(function(item, index) {
        total += Math.abs(item);
        count++;
    });

    return total / count;
}

/**
 * Prints the difference between the real values and the computed values for the corners. Only useful when using simulated
 * measurements.
 * @param {Object} guess - An object containing the x and y coordinates of the top left, top right, bottom left, and bottom right corners of a trapazoid.
 * @returns {void}
 */
function printResults(guess){
    // console.log("tlX error: " + (guess.tl.x - trueTLX) + "mm at: " + guess.tl.x);
    // console.log("tlY error: " + (guess.tl.y - trueTLY) + "mm at: " + guess.tl.y);
    // console.log("trX error: " + (guess.tr.x - trueTRX) + "mm at: " + guess.tr.x);
    // console.log("trY error: " + (guess.tr.y - trueTRY) + "mm at: " + guess.tr.y);
    // console.log("brX error: " + (guess.br.x - trueBRX) + "mm at: " + guess.br.x);

    let output = document.getElementById('output');
    let guessString = "Fitness: " + 1/guess.fitness + "(" + guess.tl.x + ", " + guess.tl.y + "), (" + guess.tr.x + ", " + guess.tr.y + ")\n (" + guess.bl.x + ", " + guess.bl.y + "), (" + guess.br.x + ", " + guess.br.y + ")";
    output.value += guessString + "\n";

}

/**
 * Projects the measurements to the plane of the machine. This is needed
 * because the belts are not parallel to the surface of the machine.
 * @param {Object} measurement - An object containing the measurements
 * @returns {Object} - An object containing the projected measurements
 */
function projectMeasurement(measurement){
    const tl = Math.sqrt(Math.pow(measurement.tl,2) - Math.pow(tlZ,2));
    const tr = Math.sqrt(Math.pow(measurement.tr,2) - Math.pow(trZ,2));
    const bl = Math.sqrt(Math.pow(measurement.bl,2) - Math.pow(blZ,2));
    const br = Math.sqrt(Math.pow(measurement.br,2) - Math.pow(brZ,2));

    return {tl: tl, tr: tr, bl: bl, br: br};
}

/**
 * Projects an array of measurements to the plane of the machine to account for the fact that the start and end point are not in the same plane.
 * @param {Object[]} measurements - An array of objects containing the measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 * @returns {Object[]} - An array of objects containing the projected measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 */
function projectMeasurements(measurements){
    var projectedMeasurements = [];

    measurements.forEach(measurement => {
        projectedMeasurements.push(projectMeasurement(measurement));
    });

    return projectedMeasurements;
}

/**
 * Adds a constant to each measurement in an array of measurements.
 * @param {Object[]} measurements - An array of objects containing the measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 * @param {number} offset - The constant to add to each measurement.
 * @returns {Object[]} - An array of objects containing the updated measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 */
function offsetMeasurements(measurements, offset) {
    const newMeasurements = measurements.map(measurement => {
        return {
            tl: measurement.tl + offset,
            tr: measurement.tr + offset,
            bl: measurement.bl + offset,
            br: measurement.br + offset
        };
    });

    return newMeasurements;
}

/**
 * Scales each measurement in an array of measurements by a constant. 
 * @param {Object[]} measurements - An array of objects containing the measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 * @param {number} scale - The constant to multiply each measurement by.
 * @returns {Object[]} - An array of objects containing the updated measurements of the top left, top right, bottom left, and bottom right corners of a rectangle.
 */
function scaleMeasurements(measurements, scale) {
    const newMeasurements = measurements.map(measurement => {
        return {
            tl: measurement.tl * scale,
            tr: measurement.tr * scale,
            bl: measurement.bl,  // * scale,
            br: measurement.br,  // * scale
        };
    });

    return newMeasurements;
}

function scaleMeasurementsBasedOnTension(measurements, guess) {

    const maxScale = 0.995;
    const minScale = 0.994;
    const maxTension = 60;
    const minTension = 20;

    const scaleRange = maxScale - minScale;
    const tensionRange = maxTension - minTension;
    

    const newMeasurements = measurements.map(measurement => {

        const tensionAdjustedTLScale = (1 - ((measurement.TLtension - minTension) / tensionRange)) * scaleRange + minScale;
        const tensionAdjustedTRScale = (1 - ((measurement.TRtension - minTension) / tensionRange)) * scaleRange + minScale;
        
        return {
            tl: measurement.tl * tensionAdjustedTLScale,
            tr: measurement.tr * tensionAdjustedTRScale,
            bl: measurement.bl,  // * scale,
            br: measurement.br,  // * scale
        };
    });

    return newMeasurements;
}

/**
 * Estimates initial frame dimensions from measurement data by analyzing
 * the relationships between distances to different corners.
 * Uses the insight that max corner distances relate to the frame diagonal.
 * @param {Array} measurements - Array of measurement objects with {bl, br, tr, tl} distances
 * @returns {Object} - Estimated {width, height} in mm
 */
function estimateFrameDimensionsFromMeasurements(measurements) {
    // Find maximum distance to each corner across all measurements
    // The max distance to any corner approximates the diagonal of the frame
    const maxBL = Math.max(...measurements.map(m => m.bl));
    const maxBR = Math.max(...measurements.map(m => m.br));
    const maxTR = Math.max(...measurements.map(m => m.tr));
    const maxTL = Math.max(...measurements.map(m => m.tl));
    
    // The diagonal of the frame is approximately the max distance to any corner
    const diagonal = Math.max(maxBL, maxBR, maxTR, maxTL);
    
    // Also compute averages for aspect ratio estimation
    let avgBL = 0, avgBR = 0, avgTR = 0, avgTL = 0;
    measurements.forEach(m => {
        avgBL += m.bl;
        avgBR += m.br;
        avgTR += m.tr;
        avgTL += m.tl;
    });
    const count = measurements.length;
    avgBL /= count;
    avgBR /= count;
    avgTR /= count;
    avgTL /= count;
    
    // Estimate aspect ratio by comparing left/right vs top/bottom distances
    // If BR+BL > TR+TL, frame is likely wider (more horizontal spread)
    // If TR+TL > BR+BL, frame is likely taller (more vertical spread)
    const horizontalSpread = (avgBR + avgBL) / 2;
    const verticalSpread = (avgTR + avgTL) / 2;
    
    // Use the ratio to estimate width vs height
    // This is a heuristic based on the observation that:
    // - Larger horizontal distances suggest a wider frame
    // - Larger vertical distances suggest a taller frame
    const totalSpread = horizontalSpread + verticalSpread;
    const widthRatio = horizontalSpread / totalSpread;
    const heightRatio = verticalSpread / totalSpread;
    
    // For a rectangular frame, diagonal² = width² + height²
    // We know diagonal, and we have ratio information
    // If widthRatio:heightRatio = w:h, and w² + h² = diagonal²
    // Then w = diagonal * sqrt(widthRatio² / (widthRatio² + heightRatio²))
    const diagonalSq = diagonal * diagonal;
    const ratioSumSq = widthRatio * widthRatio + heightRatio * heightRatio;
    
    let width = diagonal * widthRatio / Math.sqrt(ratioSumSq);
    let height = diagonal * heightRatio / Math.sqrt(ratioSumSq);
    
    // Ensure reasonable bounds
    width = Math.max(1000, Math.min(10000, width));
    height = Math.max(1000, Math.min(10000, height));
    
    console.log(`Frame dimension estimation from measurements:`);
    console.log(`  Max distances - BL: ${maxBL.toFixed(1)}mm, BR: ${maxBR.toFixed(1)}mm, TR: ${maxTR.toFixed(1)}mm, TL: ${maxTL.toFixed(1)}mm`);
    console.log(`  Estimated diagonal: ${diagonal.toFixed(1)}mm`);
    console.log(`  Average distances - BL: ${avgBL.toFixed(1)}mm, BR: ${avgBR.toFixed(1)}mm, TR: ${avgTR.toFixed(1)}mm, TL: ${avgTL.toFixed(1)}mm`);
    console.log(`  Spread indicators - Horizontal: ${horizontalSpread.toFixed(1)}mm, Vertical: ${verticalSpread.toFixed(1)}mm`);
    console.log(`  Ratio - Width: ${widthRatio.toFixed(3)}, Height: ${heightRatio.toFixed(3)}`);
    console.log(`  Final estimate: ${width.toFixed(1)}mm × ${height.toFixed(1)}mm`);
    
    return { width, height };
}

/**
 * Searches for the best rectangular starting configuration by testing all combinations
 * of width and height in 100mm increments up to 5000mm.
 * Assumes bl=(0,0), br.y=0, and rectangular frame (tl.x=0, tl.y=tr.y, br.x=tr.x)
 * @param {Array} measurements - Array of measurement objects
 * @returns {Promise<Object>} - Promise that resolves to best guess configuration with highest fitness
 */
// 3D Surface Map Visualization State
let surfaceMapState = {
    rotationX: -30,
    rotationY: 45,
    zoom: 0.15,
    offsetX: 0,
    offsetY: 0
};

async function findBestRectangularStart(measurements) {
    const messagesBox = document.getElementById('output');
    const searchInfo = document.getElementById('search-info');
    const canvas = document.getElementById('surface-map-canvas');
    const searchStatus = document.getElementById('search-status');
    
    // Arc spacing is now fixed at 1mm for optimal precision
    const arcSpacing = 1;
    
    // Show 3D visualization elements
    searchInfo.style.display = 'block';
    canvas.style.display = 'block';
    
    messagesBox.value = "Searching for best starting configuration...\n";
    messagesBox.value += "Phase 1: Finding optimal radius along diagonal using ternary search...\n";
    searchStatus.textContent = "Phase 1: Ternary search for optimal radius...";
    
    // Deep copy measurements to avoid mutation during search
    const measurementsCopy = JSON.parse(JSON.stringify(measurements));
    
    // PHASE 0: Estimate initial frame dimensions from measurement data
    console.log(`\n=== PHASE 0: ESTIMATING FRAME DIMENSIONS FROM MEASUREMENTS ===`);
    messagesBox.value += `Phase 0: Estimating frame dimensions from measurement data...\n`;
    
    const estimatedDims = estimateFrameDimensionsFromMeasurements(measurementsCopy);
    const estWidth = Math.round(estimatedDims.width);
    const estHeight = Math.round(estimatedDims.height);
    
    console.log(`\nEstimated dimensions: ${estWidth}mm × ${estHeight}mm`);
    messagesBox.value += `  Estimated dimensions: ${estWidth}mm × ${estHeight}mm\n`;
    messagesBox.value += `\n`;
    
    // PHASE 1: Coarse 2D grid search followed by local refinement
    // This approach avoids local optima by testing the full parameter space first
    console.log(`\n=== PHASE 1: COARSE 2D GRID SEARCH ===`);
    messagesBox.value += `Phase 1: Searching for optimal frame dimensions using 2D grid...\n`;
    searchStatus.textContent = `Phase 1: Coarse 2D grid search...`;
    
    let phase1TestCount = 0;
    let bestWidth = estWidth;
    let bestHeight = estHeight;
    let bestFitness = Infinity;
    
    // PHASE 1A: Coarse 2D grid search to find the global optimum region
    // Use larger steps to cover wide range efficiently (300mm steps)
    // Expand width range to cover expected 4576mm width
    const coarseWidthMin = 2000;
    const coarseWidthMax = 7000;  // Increased to cover wider frames
    const coarseHeightMin = 2000;
    const coarseHeightMax = 6500;
    const coarseStep = 300;
    
    console.log(`\n=== PHASE 1A: COARSE GRID SEARCH ===`);
    console.log(`Width range: ${coarseWidthMin}mm to ${coarseWidthMax}mm (step ${coarseStep}mm)`);
    console.log(`Height range: ${coarseHeightMin}mm to ${coarseHeightMax}mm (step ${coarseStep}mm)`);
    
    const widthSteps = Math.floor((coarseWidthMax - coarseWidthMin) / coarseStep) + 1;
    const heightSteps = Math.floor((coarseHeightMax - coarseHeightMin) / coarseStep) + 1;
    const totalCoarseTests = widthSteps * heightSteps;
    
    console.log(`Total coarse tests: ${totalCoarseTests}`);
    messagesBox.value += `Phase 1A: Coarse grid search (${coarseStep}mm steps, ~${totalCoarseTests} tests)...\n`;
    
    // Collect fitness data for visualization
    const fitnessData = [];
    const widthValues = [];
    const heightValues = [];
    
    for (let w = coarseWidthMin; w <= coarseWidthMax; w += coarseStep) {
        widthValues.push(w);
    }
    for (let h = coarseHeightMin; h <= coarseHeightMax; h += coarseStep) {
        heightValues.push(h);
    }
    
    // Initialize 2D array for fitness data
    for (let i = 0; i < heightValues.length; i++) {
        fitnessData[i] = [];
    }
    
    for (let w = coarseWidthMin; w <= coarseWidthMax; w += coarseStep) {
        for (let h = coarseHeightMin; h <= coarseHeightMax; h += coarseStep) {
            const guess = {
                tl: {x: 0, y: h},
                tr: {x: w, y: h},
                bl: {x: 0, y: 0},
                br: {x: w, y: 0},
                fitness: 0
            };
            
            const result = computeLinesFitness(measurementsCopy, guess, true);
            phase1TestCount++;
            
            // Store fitness data for visualization (use display fitness 1/raw)
            const displayFitness = 1 / result.fitness;
            const widthIdx = widthValues.indexOf(w);
            const heightIdx = heightValues.indexOf(h);
            fitnessData[heightIdx][widthIdx] = {
                width: w,
                height: h,
                rawFitness: result.fitness,
                displayFitness: displayFitness
            };
            
            if (result.fitness < bestFitness) {
                bestFitness = result.fitness;
                bestWidth = w;
                bestHeight = h;
                console.log(`[Test #${phase1TestCount}] New best: ${w}×${h}mm, fitness: ${result.fitness.toFixed(6)}`);
            }
            
            // Update progress every 20 tests
            if (phase1TestCount % 20 === 0) {
                const progress = (phase1TestCount / totalCoarseTests * 100).toFixed(1);
                searchStatus.textContent = `Phase 1A: Coarse grid (${phase1TestCount}/${totalCoarseTests}, ${progress}%) - Best: ${bestWidth}×${bestHeight}mm`;
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
    }
    
    console.log(`\n=== PHASE 1A COMPLETE ===`);
    console.log(`Coarse search tested ${phase1TestCount} configurations`);
    console.log(`Best coarse result: ${bestWidth}×${bestHeight}mm, fitness: ${bestFitness.toFixed(6)}`);
    messagesBox.value += `Phase 1A complete: Best coarse result = ${bestWidth}×${bestHeight}mm (fitness ${bestFitness.toFixed(6)})\n`;
    
    // PHASE 1B: Medium refinement around best coarse result
    // Search ±coarseStep around best result with medium steps (100mm)
    console.log(`\n=== PHASE 1B: MEDIUM REFINEMENT ===`);
    messagesBox.value += `Phase 1B: Medium refinement around ${bestWidth}×${bestHeight}mm...\n`;
    
    const mediumWidthMin = Math.max(2000, bestWidth - coarseStep);
    const mediumWidthMax = Math.min(10000, bestWidth + coarseStep);
    const mediumHeightMin = Math.max(2000, bestHeight - coarseStep);
    const mediumHeightMax = Math.min(10000, bestHeight + coarseStep);
    const mediumStep = 100;
    
    console.log(`Width range: ${mediumWidthMin}mm to ${mediumWidthMax}mm (step ${mediumStep}mm)`);
    console.log(`Height range: ${mediumHeightMin}mm to ${mediumHeightMax}mm (step ${mediumStep}mm)`);
    
    for (let w = mediumWidthMin; w <= mediumWidthMax; w += mediumStep) {
        for (let h = mediumHeightMin; h <= mediumHeightMax; h += mediumStep) {
            const guess = {
                tl: {x: 0, y: h},
                tr: {x: w, y: h},
                bl: {x: 0, y: 0},
                br: {x: w, y: 0},
                fitness: 0
            };
            
            const result = computeLinesFitness(measurementsCopy, guess, true);
            phase1TestCount++;
            
            if (result.fitness < bestFitness) {
                bestFitness = result.fitness;
                bestWidth = w;
                bestHeight = h;
                console.log(`[Test #${phase1TestCount}] New best: ${w}×${h}mm, fitness: ${result.fitness.toFixed(6)}`);
            }
        }
    }
    
    console.log(`\n=== PHASE 1B COMPLETE ===`);
    console.log(`Best medium result: ${bestWidth}×${bestHeight}mm, fitness: ${bestFitness.toFixed(6)}`);
    messagesBox.value += `Phase 1B complete: Best medium result = ${bestWidth}×${bestHeight}mm (fitness ${bestFitness.toFixed(6)})\n`;
    
    // PHASE 1C: Fine local refinement
    // Search ±150mm around best result with fine steps (25mm)
    console.log(`\n=== PHASE 1C: FINE LOCAL REFINEMENT ===`);
    messagesBox.value += `Phase 1C: Fine refinement around ${bestWidth}×${bestHeight}mm...\n`;
    
    let finalWidth = bestWidth;
    let finalHeight = bestHeight;
    let finalFitness = bestFitness;
    
    const fineRange = 150;
    const fineStep = 25;
    const fineWidthMin = Math.max(2000, bestWidth - fineRange);
    const fineWidthMax = Math.min(10000, bestWidth + fineRange);
    const fineHeightMin = Math.max(2000, bestHeight - fineRange);
    const fineHeightMax = Math.min(10000, bestHeight + fineRange);
    
    console.log(`Width range: ${fineWidthMin}mm to ${fineWidthMax}mm (step ${fineStep}mm)`);
    console.log(`Height range: ${fineHeightMin}mm to ${fineHeightMax}mm (step ${fineStep}mm)`);
    
    for (let w = fineWidthMin; w <= fineWidthMax; w += fineStep) {
        for (let h = fineHeightMin; h <= fineHeightMax; h += fineStep) {
            const guess = {
                tl: {x: 0, y: h},
                tr: {x: w, y: h},
                bl: {x: 0, y: 0},
                br: {x: w, y: 0},
                fitness: 0
            };
            
            const result = computeLinesFitness(measurementsCopy, guess, true);
            phase1TestCount++;
            
            if (result.fitness < finalFitness) {
                finalFitness = result.fitness;
                finalWidth = w;
                finalHeight = h;
                console.log(`[Test #${phase1TestCount}] New best: ${w}×${h}mm, fitness: ${result.fitness.toFixed(6)}`);
            }
        }
    }
    
    console.log(`\n=== PHASE 1C COMPLETE ===`);
    console.log(`Final best: ${finalWidth}×${finalHeight}mm, fitness: ${finalFitness.toFixed(6)}`);
    console.log(`Total Phase 1 tests: ${phase1TestCount}`);
    messagesBox.value += `Phase 1C complete: Final dimensions = ${finalWidth}×${finalHeight}mm (fitness ${finalFitness.toFixed(6)})\n`;
    messagesBox.value += `Total Phase 1 tests: ${phase1TestCount}\n`;
    messagesBox.value += `\n`;
    
    // Create the best guess from Phase 1 results
    const bestGuess = {
        tl: {x: 0, y: finalHeight},
        tr: {x: finalWidth, y: finalHeight},
        bl: {x: 0, y: 0},
        br: {x: finalWidth, y: 0},
        fitness: finalFitness
    };
    
    // Store tested points for visualization (using the best result)
    const testedPoints = [{
        width: finalWidth,
        height: finalHeight,
        fitness: 1 / finalFitness,
        rawFitness: finalFitness
    }];
    
    // Final render - show fitness landscape heatmap
    searchStatus.textContent = "Rendering fitness landscape heatmap...";
    await new Promise(resolve => setTimeout(resolve, 100));
    
    renderFitnessLandscape(canvas, fitnessData, widthValues, heightValues, bestWidth, bestHeight, finalWidth, finalHeight);
    
    // Setup controls
    setupFitnessLandscapeControls(canvas, fitnessData, widthValues, heightValues, bestWidth, bestHeight, finalWidth, finalHeight);
    
    searchStatus.textContent = `✓ Search complete! Tested ${phase1TestCount} points. Best: ${finalWidth.toFixed(1)}×${finalHeight.toFixed(1)}mm, fitness: ${(1/finalFitness).toFixed(4)}`;
    messagesBox.value += `\n✓ Search complete! Tested ${phase1TestCount} configurations.\n\nBest rectangular start:\n  Width: ${finalWidth.toFixed(1)}mm\n  Height: ${finalHeight.toFixed(1)}mm\n  Fitness: ${(1/finalFitness).toFixed(4)}\n\nStarting optimization...\n`;
    messagesBox.scrollTop = messagesBox.scrollHeight;
    
    return bestGuess;
}

function render3DSurface(canvas, fitnessData, widthValues, heightValues, bestGuess) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, width, height);
    
    // Find min and max fitness for color mapping (excluding zero/uncomputed values)
    let minFitness = Infinity;
    let maxFitness = -Infinity;
    for (let i = 0; i < fitnessData.length; i++) {
        for (let j = 0; j < fitnessData[i].length; j++) {
            if (fitnessData[i][j] > 0) {  // Only consider non-zero computed values
                minFitness = Math.min(minFitness, fitnessData[i][j]);
                maxFitness = Math.max(maxFitness, fitnessData[i][j]);
            }
        }
    }
    
    // Project 3D points to 2D using isometric projection
    function project3D(x, y, z) {
        const angleX = surfaceMapState.rotationX * Math.PI / 180;
        const angleY = surfaceMapState.rotationY * Math.PI / 180;
        
        // Rotate around Y axis
        let x1 = x * Math.cos(angleY) + z * Math.sin(angleY);
        let z1 = -x * Math.sin(angleY) + z * Math.cos(angleY);
        let y1 = y;
        
        // Rotate around X axis
        let y2 = y1 * Math.cos(angleX) - z1 * Math.sin(angleX);
        let z2 = y1 * Math.sin(angleX) + z1 * Math.cos(angleX);
        let x2 = x1;
        
        // Apply zoom and offset
        const screenX = width / 2 + x2 * surfaceMapState.zoom + surfaceMapState.offsetX;
        const screenY = height / 2 - y2 * surfaceMapState.zoom + surfaceMapState.offsetY;
        
        return { x: screenX, y: screenY, z: z2 };
    }
    
    // Draw surface with faces (only for non-zero fitness values)
    const faces = [];
    for (let i = 0; i < widthValues.length - 1; i++) {
        for (let j = 0; j < heightValues.length - 1; j++) {
            // Skip rendering if all corners have zero fitness (not computed)
            if (fitnessData[i][j] === 0 && fitnessData[i + 1][j] === 0 && 
                fitnessData[i][j + 1] === 0 && fitnessData[i + 1][j + 1] === 0) {
                continue;
            }
            
            const x = widthValues[i] - 2500;
            const y = heightValues[j] - 2500;
            const x1 = widthValues[i + 1] - 2500;
            const y1 = heightValues[j + 1] - 2500;
            
            const z00 = ((fitnessData[i][j] - minFitness) / (maxFitness - minFitness)) * 1000;
            const z10 = ((fitnessData[i + 1][j] - minFitness) / (maxFitness - minFitness)) * 1000;
            const z01 = ((fitnessData[i][j + 1] - minFitness) / (maxFitness - minFitness)) * 1000;
            const z11 = ((fitnessData[i + 1][j + 1] - minFitness) / (maxFitness - minFitness)) * 1000;
            
            const p00 = project3D(x, y, z00);
            const p10 = project3D(x1, y, z10);
            const p01 = project3D(x, y1, z01);
            const p11 = project3D(x1, y1, z11);
            
            // Average Z for face sorting
            const avgZ = (p00.z + p10.z + p01.z + p11.z) / 4;
            const avgFitness = (fitnessData[i][j] + fitnessData[i + 1][j] + fitnessData[i][j + 1] + fitnessData[i + 1][j + 1]) / 4;
            const normalized = (avgFitness - minFitness) / (maxFitness - minFitness);
            
            faces.push({ p00, p10, p01, p11, avgZ, normalized });
        }
    }
    
    // Sort faces by Z (painter's algorithm)
    faces.sort((a, b) => a.avgZ - b.avgZ);
    
    // Draw faces
    for (const face of faces) {
        // Color gradient from blue (low) to red (high)
        const hue = (1 - face.normalized) * 240; // 240 = blue, 0 = red
        const saturation = 80;
        const lightness = 40 + face.normalized * 30;
        
        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness - 10}%)`;
        ctx.lineWidth = 0.5;
        
        ctx.beginPath();
        ctx.moveTo(face.p00.x, face.p00.y);
        ctx.lineTo(face.p10.x, face.p10.y);
        ctx.lineTo(face.p11.x, face.p11.y);
        ctx.lineTo(face.p01.x, face.p01.y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
    
    // Mark the best point
    if (bestGuess) {
        const bestWidthIndex = widthValues.indexOf(bestGuess.tr.x);
        const bestHeightIndex = heightValues.indexOf(bestGuess.tr.y);
        if (bestWidthIndex >= 0 && bestHeightIndex >= 0) {
            const x = bestGuess.tr.x - 2500;
            const y = bestGuess.tr.y - 2500;
            const z = ((fitnessData[bestWidthIndex][bestHeightIndex] - minFitness) / (maxFitness - minFitness)) * 1000 + 50;
            const p = project3D(x, y, z);
            
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
    
    // Draw legend
    ctx.fillStyle = 'black';
    ctx.font = '12px monospace';
    ctx.fillText(`Fitness Range: ${minFitness.toFixed(4)} - ${maxFitness.toFixed(4)}`, 10, 20);
    ctx.fillText('Blue = Low Fitness, Red = High Fitness', 10, 40);
    ctx.fillText('Red Dot = Best Configuration', 10, 60);
}

function setupSurfaceMapControls(canvas, fitnessData, widthValues, heightValues, bestGuess) {
    // Mouse drag to rotate
    let isDragging = false;
    let lastX = 0, lastY = 0;
    
    canvas.onmousedown = (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    };
    
    canvas.onmousemove = (e) => {
        if (isDragging) {
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            
            surfaceMapState.rotationY += deltaX * 0.5;
            surfaceMapState.rotationX += deltaY * 0.5;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            render3DSurface(canvas, fitnessData, widthValues, heightValues, bestGuess);
        }
    };
    
    canvas.onmouseup = () => {
        isDragging = false;
    };
    
    canvas.onmouseleave = () => {
        isDragging = false;
    };
    
    // Mouse wheel to zoom
    canvas.onwheel = (e) => {
        e.preventDefault();
        if (e.deltaY < 0) {
            surfaceMapState.zoom *= 1.1;
        } else {
            surfaceMapState.zoom /= 1.1;
        }
        render3DSurface(canvas, fitnessData, widthValues, heightValues, bestGuess);
    };
}

function render3DSurfaceArc(canvas, testedPoints, bestGuess) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, width, height);
    
    if (testedPoints.length === 0) return;
    
    // Find min and max fitness for color mapping
    let minFitness = Infinity;
    let maxFitness = -Infinity;
    for (const point of testedPoints) {
        minFitness = Math.min(minFitness, point.fitness);
        maxFitness = Math.max(maxFitness, point.fitness);
    }
    
    // Project 3D points to 2D using isometric projection
    function project3D(x, y, z) {
        const angleX = surfaceMapState.rotationX * Math.PI / 180;
        const angleY = surfaceMapState.rotationY * Math.PI / 180;
        
        // Rotate around Y axis
        let x1 = x * Math.cos(angleY) + z * Math.sin(angleY);
        let z1 = -x * Math.sin(angleY) + z * Math.cos(angleY);
        let y1 = y;
        
        // Rotate around X axis
        let y2 = y1 * Math.cos(angleX) - z1 * Math.sin(angleX);
        let z2 = y1 * Math.sin(angleX) + z1 * Math.cos(angleX);
        let x2 = x1;
        
        // Apply zoom and offset
        const screenX = width / 2 + x2 * surfaceMapState.zoom + surfaceMapState.offsetX;
        const screenY = height / 2 - y2 * surfaceMapState.zoom + surfaceMapState.offsetY;
        
        return { x: screenX, y: screenY, z: z2 };
    }
    
    // Project all points and sort by Z for proper rendering order
    const projectedPoints = testedPoints.map(point => {
        const x = point.width - 2500;
        const y = point.height - 2500;
        const z = ((point.fitness - minFitness) / (maxFitness - minFitness)) * 1000;
        const projected = project3D(x, y, z);
        const normalized = (point.fitness - minFitness) / (maxFitness - minFitness);
        return { ...projected, normalized, originalPoint: point };
    });
    
    // Sort by Z depth (painter's algorithm)
    projectedPoints.sort((a, b) => a.z - b.z);
    
    // Draw points as circles
    for (const point of projectedPoints) {
        // Color gradient from blue (low) to red (high)
        const hue = (1 - point.normalized) * 240; // 240 = blue, 0 = red
        const saturation = 80;
        const lightness = 40 + point.normalized * 30;
        
        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness - 10}%)`;
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
    }
    
    // Draw connecting lines between adjacent points on the arc to show the curve
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < projectedPoints.length; i++) {
        const point = projectedPoints[i];
        if (i === 0) {
            ctx.moveTo(point.x, point.y);
        } else {
            ctx.lineTo(point.x, point.y);
        }
    }
    ctx.stroke();
    
    // Mark the best point
    if (bestGuess) {
        const bestPoint = testedPoints.find(p => 
            Math.abs(p.width - bestGuess.tr.x) < 0.1 && 
            Math.abs(p.height - bestGuess.tr.y) < 0.1
        );
        if (bestPoint) {
            const x = bestPoint.width - 2500;
            const y = bestPoint.height - 2500;
            const z = ((bestPoint.fitness - minFitness) / (maxFitness - minFitness)) * 1000 + 50;
            const p = project3D(x, y, z);
            
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
    
    // Draw 3D axes
    const axisLength = 500;
    const axisOrigin = { x: -2500, y: -2500, z: 0 };
    
    // X axis (Width) - Red
    const xAxisStart = project3D(axisOrigin.x, axisOrigin.y, axisOrigin.z);
    const xAxisEnd = project3D(axisOrigin.x + axisLength, axisOrigin.y, axisOrigin.z);
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xAxisStart.x, xAxisStart.y);
    ctx.lineTo(xAxisEnd.x, xAxisEnd.y);
    ctx.stroke();
    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('Width (mm)', xAxisEnd.x + 10, xAxisEnd.y);
    
    // Y axis (Height) - Green
    const yAxisStart = project3D(axisOrigin.x, axisOrigin.y, axisOrigin.z);
    const yAxisEnd = project3D(axisOrigin.x, axisOrigin.y + axisLength, axisOrigin.z);
    ctx.strokeStyle = 'rgba(0, 180, 0, 0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(yAxisStart.x, yAxisStart.y);
    ctx.lineTo(yAxisEnd.x, yAxisEnd.y);
    ctx.stroke();
    ctx.fillStyle = 'rgba(0, 180, 0, 0.8)';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('Height (mm)', yAxisEnd.x + 10, yAxisEnd.y);
    
    // Z axis (Fitness) - Blue
    const zAxisStart = project3D(axisOrigin.x, axisOrigin.y, axisOrigin.z);
    const zAxisEnd = project3D(axisOrigin.x, axisOrigin.y, axisLength);
    ctx.strokeStyle = 'rgba(0, 0, 255, 0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(zAxisStart.x, zAxisStart.y);
    ctx.lineTo(zAxisEnd.x, zAxisEnd.y);
    ctx.stroke();
    ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('Fitness', zAxisEnd.x + 10, zAxisEnd.y);
    
    // Draw legend
    ctx.fillStyle = 'black';
    ctx.font = '12px monospace';
    ctx.fillText(`Fitness Range: ${minFitness.toFixed(4)} - ${maxFitness.toFixed(4)}`, 10, 20);
    ctx.fillText('Blue = Low Fitness, Red = High Fitness', 10, 35);
    ctx.fillText('Red Dot = Best Configuration', 10, 50);
}

function setupSurfaceMapControlsArc(canvas, testedPoints, bestGuess) {
    // Mouse drag to rotate
    let isDragging = false;
    let lastX = 0, lastY = 0;
    
    canvas.onmousedown = (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    };
    
    canvas.onmousemove = (e) => {
        if (isDragging) {
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            
            surfaceMapState.rotationY += deltaX * 0.5;
            surfaceMapState.rotationX += deltaY * 0.5;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            render3DSurfaceArc(canvas, testedPoints, bestGuess);
        }
    };
    
    canvas.onmouseup = () => {
        isDragging = false;
    };
    
    canvas.onmouseleave = () => {
        isDragging = false;
    };
    
    // Mouse wheel to zoom
    canvas.onwheel = (e) => {
        e.preventDefault();
        if (e.deltaY < 0) {
            surfaceMapState.zoom *= 1.1;
        } else {
            surfaceMapState.zoom /= 1.1;
        }
        render3DSurfaceArc(canvas, testedPoints, bestGuess);
    };
}

// Fitness Landscape Visualization Functions
function renderFitnessLandscape(canvas, fitnessData, widthValues, heightValues, coarseBestWidth, coarseBestHeight, finalWidth, finalHeight) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, width, height);
    
    // Calculate cell dimensions
    const padding = 80;
    const legendWidth = 150;
    const plotWidth = width - 2 * padding - legendWidth;
    const plotHeight = height - 2 * padding;
    const cellWidth = plotWidth / widthValues.length;
    const cellHeight = plotHeight / heightValues.length;
    
    // Find min/max fitness for color scaling
    let minFitness = Infinity;
    let maxFitness = -Infinity;
    for (let i = 0; i < fitnessData.length; i++) {
        for (let j = 0; j < fitnessData[i].length; j++) {
            const displayFitness = fitnessData[i][j].displayFitness;
            if (displayFitness < minFitness) minFitness = displayFitness;
            if (displayFitness > maxFitness) maxFitness = displayFitness;
        }
    }
    
    // Draw title
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Fitness Landscape Heatmap', width / 2, 30);
    ctx.font = '12px sans-serif';
    ctx.fillText('(Brighter = Better Fitness)', width / 2, 50);
    
    // Draw heatmap
    for (let i = 0; i < heightValues.length; i++) {
        for (let j = 0; j < widthValues.length; j++) {
            const data = fitnessData[i][j];
            const x = padding + j * cellWidth;
            const y = padding + (heightValues.length - 1 - i) * cellHeight;
            
            // Color based on fitness (normalized)
            const normalizedFitness = (data.displayFitness - minFitness) / (maxFitness - minFitness);
            
            // Use a color gradient from dark blue (low) to bright yellow (high)
            let r, g, b;
            if (normalizedFitness < 0.5) {
                // Dark blue to cyan
                const t = normalizedFitness * 2;
                r = 0;
                g = Math.floor(t * 150);
                b = Math.floor(100 + t * 155);
            } else {
                // Cyan to yellow
                const t = (normalizedFitness - 0.5) * 2;
                r = Math.floor(t * 255);
                g = Math.floor(150 + t * 105);
                b = Math.floor(255 - t * 255);
            }
            
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.fillRect(x, y, cellWidth, cellHeight);
        }
    }
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= widthValues.length; i++) {
        const x = padding + i * cellWidth;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, padding + plotHeight);
        ctx.stroke();
    }
    for (let i = 0; i <= heightValues.length; i++) {
        const y = padding + i * cellHeight;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + plotWidth, y);
        ctx.stroke();
    }
    
    // Mark coarse best result (red circle)
    const coarseBestWidthIdx = widthValues.indexOf(coarseBestWidth);
    const coarseBestHeightIdx = heightValues.indexOf(coarseBestHeight);
    if (coarseBestWidthIdx >= 0 && coarseBestHeightIdx >= 0) {
        const x = padding + (coarseBestWidthIdx + 0.5) * cellWidth;
        const y = padding + (heightValues.length - 1 - coarseBestHeightIdx + 0.5) * cellHeight;
        ctx.strokeStyle = '#ff0000';
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, 15, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
    }
    
    // Mark final result (green X)
    // Find closest point in grid
    let closestWidthIdx = 0;
    let closestHeightIdx = 0;
    let minWidthDist = Infinity;
    let minHeightDist = Infinity;
    for (let i = 0; i < widthValues.length; i++) {
        const dist = Math.abs(widthValues[i] - finalWidth);
        if (dist < minWidthDist) {
            minWidthDist = dist;
            closestWidthIdx = i;
        }
    }
    for (let i = 0; i < heightValues.length; i++) {
        const dist = Math.abs(heightValues[i] - finalHeight);
        if (dist < minHeightDist) {
            minHeightDist = dist;
            closestHeightIdx = i;
        }
    }
    
    const finalX = padding + (closestWidthIdx + 0.5) * cellWidth;
    const finalY = padding + (heightValues.length - 1 - closestHeightIdx + 0.5) * cellHeight;
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    const crossSize = 12;
    ctx.beginPath();
    ctx.moveTo(finalX - crossSize, finalY - crossSize);
    ctx.lineTo(finalX + crossSize, finalY + crossSize);
    ctx.moveTo(finalX + crossSize, finalY - crossSize);
    ctx.lineTo(finalX - crossSize, finalY + crossSize);
    ctx.stroke();
    
    // Draw axes labels
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    
    // X-axis (Width)
    ctx.fillText('Width (mm)', padding + plotWidth / 2, height - 20);
    for (let i = 0; i < widthValues.length; i += 2) {
        const x = padding + (i + 0.5) * cellWidth;
        ctx.fillText(widthValues[i].toString(), x, height - 40);
    }
    
    // Y-axis (Height)
    ctx.save();
    ctx.translate(20, padding + plotHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Height (mm)', 0, 0);
    ctx.restore();
    
    ctx.textAlign = 'right';
    for (let i = 0; i < heightValues.length; i += 2) {
        const y = padding + (heightValues.length - 1 - i + 0.5) * cellHeight;
        ctx.fillText(heightValues[i].toString(), padding - 10, y + 5);
    }
    
    // Draw legend
    const legendX = width - legendWidth + 20;
    const legendY = padding;
    const legendHeight = plotHeight;
    const legendBarWidth = 30;
    
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Fitness', legendX, legendY - 10);
    
    // Draw color bar
    const barSteps = 100;
    for (let i = 0; i < barSteps; i++) {
        const y = legendY + (barSteps - 1 - i) * (legendHeight / barSteps);
        const t = i / (barSteps - 1);
        
        let r, g, b;
        if (t < 0.5) {
            const tt = t * 2;
            r = 0;
            g = Math.floor(tt * 150);
            b = Math.floor(100 + tt * 155);
        } else {
            const tt = (t - 0.5) * 2;
            r = Math.floor(tt * 255);
            g = Math.floor(150 + tt * 105);
            b = Math.floor(255 - tt * 255);
        }
        
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillRect(legendX, y, legendBarWidth, legendHeight / barSteps + 1);
    }
    
    // Draw legend labels
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(maxFitness.toFixed(2), legendX + legendBarWidth + 5, legendY + 5);
    ctx.fillText(minFitness.toFixed(2), legendX + legendBarWidth + 5, legendY + legendHeight);
    ctx.fillText(((minFitness + maxFitness) / 2).toFixed(2), legendX + legendBarWidth + 5, legendY + legendHeight / 2);
    
    // Draw legend for markers
    ctx.font = '12px sans-serif';
    const markerLegendY = height - 120;
    
    // Red circle for coarse best
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(legendX + 10, markerLegendY, 8, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'left';
    ctx.fillText('Coarse Best', legendX + 25, markerLegendY + 5);
    ctx.fillText(`(${coarseBestWidth}×${coarseBestHeight}mm)`, legendX + 25, markerLegendY + 20);
    
    // Green X for final result
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;
    const xSize = 8;
    ctx.beginPath();
    ctx.moveTo(legendX + 10 - xSize, markerLegendY + 50 - xSize);
    ctx.lineTo(legendX + 10 + xSize, markerLegendY + 50 + xSize);
    ctx.moveTo(legendX + 10 + xSize, markerLegendY + 50 - xSize);
    ctx.lineTo(legendX + 10 - xSize, markerLegendY + 50 + xSize);
    ctx.stroke();
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Final Result', legendX + 25, markerLegendY + 55);
    ctx.fillText(`(${finalWidth}×${finalHeight}mm)`, legendX + 25, markerLegendY + 70);
}

function setupFitnessLandscapeControls(canvas, fitnessData, widthValues, heightValues, coarseBestWidth, coarseBestHeight, finalWidth, finalHeight) {
    // Add click handler to show fitness value at clicked point
    canvas.onclick = function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const padding = 80;
        const legendWidth = 150;
        const plotWidth = canvas.width - 2 * padding - legendWidth;
        const plotHeight = canvas.height - 2 * padding;
        
        if (x >= padding && x <= padding + plotWidth && y >= padding && y <= padding + plotHeight) {
            const cellWidth = plotWidth / widthValues.length;
            const cellHeight = plotHeight / heightValues.length;
            
            const widthIdx = Math.floor((x - padding) / cellWidth);
            const heightIdx = heightValues.length - 1 - Math.floor((y - padding) / cellHeight);
            
            if (widthIdx >= 0 && widthIdx < widthValues.length && heightIdx >= 0 && heightIdx < heightValues.length) {
                const data = fitnessData[heightIdx][widthIdx];
                console.log(`Clicked: ${data.width}×${data.height}mm`);
                console.log(`  Raw fitness: ${data.rawFitness.toFixed(6)}`);
                console.log(`  Display fitness: ${data.displayFitness.toFixed(4)}`);
                alert(`Dimensions: ${data.width}×${data.height}mm\nRaw fitness: ${data.rawFitness.toFixed(6)}\nDisplay fitness (1/raw): ${data.displayFitness.toFixed(4)}`);
            }
        }
    };
}

function findMaxFitness(initialGuess, measurements) {
    sendCalibrationEvent({
      initialGuess
    }, true);

    let currentGuess = JSON.parse(JSON.stringify(initialGuess));
    let stagnantCounter = 0;
    let totalCounter = 0;
    var bestGuess = JSON.parse(JSON.stringify(initialGuess));

    // Track retry attempts and best result across all retries
    let lowFitnessRetryCount = 0;
    let bestGuessAcrossAllRetries = JSON.parse(JSON.stringify(initialGuess));
    let bestFitnessAcrossAllRetries = 1 / bestGuess.fitness;

    function iterate() {
        if (stagnantCounter < 1000 && totalCounter < 200000) {
            //Clear the canvass
            clearCanvas();

            currentGuess = computeLinesFitness(measurements, currentGuess);
            
            if (1/currentGuess.fitness > 1/bestGuess.fitness) {
                bestGuess = JSON.parse(JSON.stringify(currentGuess));
                stagnantCounter = 0;
            } else {
                stagnantCounter++;
            }
            totalCounter++;
            
            sendCalibrationEvent({
              final: false,
              guess: currentGuess,
              bestGuess: bestGuess,
              totalCounter
            });

            if(totalCounter % 100 == 0){
                const output = document.getElementById('output');
                // Append update instead of replacing
                output.value += "Optimization progress: Best fitness " + (1/bestGuess.fitness).toFixed(7) + " after " + totalCounter + " iterations\n";
                output.scrollTop = output.scrollHeight;
            }

            // Schedule the next iteration
            setTimeout(iterate, 0);
        }
        else{
            messagesBox = document.getElementById('output');

            // Track best guess across all retry attempts
            const currentFitness = 1 / bestGuess.fitness;
            if (currentFitness > bestFitnessAcrossAllRetries) {
                bestFitnessAcrossAllRetries = currentFitness;
                bestGuessAcrossAllRetries = JSON.parse(JSON.stringify(bestGuess));
            }

            if(currentFitness < acceptableCalibrationThreshold){
                messagesBox.value += '\nCalculated Fitness Too Low (' + currentFitness.toFixed(7) + ' < ' + acceptableCalibrationThreshold + ').';

                // Check if we've exceeded max retry attempts
                if (lowFitnessRetryCount >= MAX_LOW_FITNESS_RETRIES) {
                    messagesBox.value += '\n\n⚠️ Maximum retry attempts (' + MAX_LOW_FITNESS_RETRIES + ') reached.';
                    messagesBox.value += '\nBest fitness achieved: ' + bestFitnessAcrossAllRetries.toFixed(7);
                    messagesBox.value += '\n\n❌ Calibration stopped due to low fitness after maximum retries.';
                    messagesBox.value += '\nWARNING: DO NOT USE THESE CALIBRATION VALUES!';
                    messagesBox.scrollTop = messagesBox.scrollHeight;

                    sendCalibrationEvent({
                        good: false,
                        final: true,
                        maxRetriesReached: true,
                        retryCount: lowFitnessRetryCount,
                        bestGuess: bestGuessAcrossAllRetries,
                        bestFitness: bestFitnessAcrossAllRetries
                    }, true);

                    return; // Exit the function without automatic retry
                }

                lowFitnessRetryCount++;
                messagesBox.value += ' Retry ' + lowFitnessRetryCount + '/' + MAX_LOW_FITNESS_RETRIES + '...';
            }

            messagesBox.value += '\nCalibration complete \nCalibration values:';
            messagesBox.value += '\nFitness: ' + currentFitness.toFixed(7);
            messagesBox.value += '\nMaslow_tlX: ' + bestGuess.tl.x.toFixed(1);
            messagesBox.value += '\nMaslow_tlY: ' + bestGuess.tl.y.toFixed(1);
            messagesBox.value += '\nMaslow_trX: ' + bestGuess.tr.x.toFixed(1);
            messagesBox.value += '\nMaslow_trY: ' + bestGuess.tr.y.toFixed(1);
            messagesBox.value += '\nMaslow_blX: ' + bestGuess.bl.x.toFixed(1);
            messagesBox.value += '\nMaslow_blY: ' + bestGuess.bl.y.toFixed(1);
            messagesBox.value += '\nMaslow_brX: ' + bestGuess.br.x.toFixed(1);
            messagesBox.value += '\nMaslow_brY: ' + bestGuess.br.y.toFixed(1);
            messagesBox.scrollTop
            messagesBox.scrollTop = messagesBox.scrollHeight;

            if(currentFitness > acceptableCalibrationThreshold){
                // sendCommand('$/Maslow_tlX=' + bestGuess.tl.x.toFixed(1));
                // sendCommand('$/Maslow_tlY=' + bestGuess.tl.y.toFixed(1));
                // sendCommand('$/Maslow_trX=' + bestGuess.tr.x.toFixed(1));
                // sendCommand('$/Maslow_trY=' + bestGuess.tr.y.toFixed(1));
                // sendCommand('$/Maslow_blX=' + bestGuess.bl.x.toFixed(1));
                // sendCommand('$/Maslow_blY=' + bestGuess.bl.y.toFixed(1));
                // sendCommand('$/Maslow_brX=' + bestGuess.br.x.toFixed(1));
                // sendCommand('$/Maslow_brY=' + bestGuess.br.y.toFixed(1));
                // refreshSettings(current_setting_filter);
                // saveMaslowYaml();

                sendCalibrationEvent({
                    good: true,
                    final: true,
                    bestGuess: bestGuess
                }, true);

                messagesBox.value += '\nThese values have been automatically saved for you.';
                messagesBox.value += "\nYou MUST restart your machine for them to take effect...I know that is annoying, it's getting fixed ASAP. ";
                messagesBox.scrollTop
                messagesBox.scrollTop = messagesBox.scrollHeight;

                //This restarts the esp32 to prevent you from trying to move the machine after calibration
                // setTimeout(function() {
                // sendCommand('$System/Control=RESTART');
                // }, 2000);
            } else {
                // Fitness is too low, prepare for retry
                sendCalibrationEvent({
                    good: false,
                    final: true,
                    guess: bestGuess
                }, true);

                messagesBox.value += '\n Restarting with randomized anchor positions...';

                //Add ±50 to each of the corner anchor points and try again
                initialGuess.tl.x = bestGuess.tl.x + Math.random() * 100 - 50;
                initialGuess.tl.y = bestGuess.tl.y + Math.random() * 100 - 50;
                initialGuess.tr.x = bestGuess.tr.x + Math.random() * 100 - 50;
                initialGuess.tr.y = bestGuess.tr.y + Math.random() * 100 - 50;
                initialGuess.br.x = bestGuess.br.x + Math.random() * 100 - 50;

                //Reset the counters
                stagnantCounter = 0;
                totalCounter = 0;

                //Try again with different starting conditions
                bestGuess = JSON.parse(JSON.stringify(initialGuess));
                currentGuess = JSON.parse(JSON.stringify(initialGuess));

                //Restart the iteration
                setTimeout(iterate, 0);
            }
        }
    }

    // Start the iteration
    iterate();
}

/**
 * This function will allow us to hook data into events that we can just copy this file into another project
 * to have the calibration run in other contexts and still gather events from the calculations to plot things, gather data, etc.
 */
function sendCalibrationEvent(dataToSend, log = false) {
  try {
    document.body.dispatchEvent(new CustomEvent(CALIBRATION_EVENT_NAME, {
      bubbles: true,
      cancelable: true,
      detail: dataToSend
    }));
  } catch (err) {
    // Keep console.error for debugging actual errors
    console.error('Unexpected:', err);
  }
}
const CALIBRATION_EVENT_NAME = 'calibration-data';


//Creates the canvas on which the pattern will be drawn
var canvas = document.createElement('canvas');
canvas.id     = "CursorLayer";
canvas.width  = 1000;
canvas.height = 600;
canvas.style.border   = "1px solid";
document.getElementById("views").appendChild(canvas);



//Deletes everything from the canvas
function clearCanvas() {
    const canvas = document.getElementById('CursorLayer');
    const context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
}

// Computes the fitness of the next single step
const computeButton = document.getElementById('compute-button');
computeButton.addEventListener('click', () => {
    clearCanvas();
    initialGuess = computeLinesFitness(measurements, initialGuess);
    printResults(initialGuess);
});


// var initialGuess = {
//     tl: {x: 5.08, y: 2790.71},
//     tr: {x: 3650.47, y: 2811.57},
//     bl: {x: 0, y: 0},
//     br: {x: 3655.96, y: 0},
//     fitness: 0
// }
const computeConvergeButton = document.getElementById('compute-converge-button');
computeConvergeButton.addEventListener('click', async () => {
    // Always use rawMeasurements as the source to avoid theta value pollution
    // Create a fresh projected copy for evaluation
    const measurementsCopy = projectMeasurements(JSON.parse(JSON.stringify(rawMeasurements)));
    
    // Evaluate the fitness of the initial guess
    const initialGuessCopy = JSON.parse(JSON.stringify(initialGuess));
    const evaluatedGuess = computeLinesFitness(measurementsCopy, initialGuessCopy, true);
    const initialFitness = 1 / evaluatedGuess.fitness;
    
    const messagesBox = document.getElementById('output');
    const initialMessage = `Initial guess fitness: ${initialFitness.toFixed(7)}\n`;
    
    // Check if rectangular approximation is enabled
    const useRectangularApproximation = document.getElementById('use-rectangular-approximation').checked;
    
    var startingGuess;
    var decisionMessage;
    
    // Only use rectangular optimization if toggle is enabled AND initial fitness is less than 0.1 (poor guess)
    if (useRectangularApproximation && initialFitness < 0.1) {
        decisionMessage = "Initial fitness < 0.1 (poor guess), running rectangular optimization to find better starting point.\n";
        messagesBox.value = initialMessage + decisionMessage;
        messagesBox.scrollTop = messagesBox.scrollHeight;
        // Find the best rectangular starting configuration once
        // Note: findBestRectangularStart will overwrite messagesBox.value, so we prepend our messages after
        // Use a fresh copy of measurements for rectangular search
        const measurementsForRectSearch = projectMeasurements(JSON.parse(JSON.stringify(rawMeasurements)));
        startingGuess = await findBestRectangularStart(measurementsForRectSearch);
        // Prepend our initial messages
        messagesBox.value = initialMessage + decisionMessage + messagesBox.value;
    } else {
        if (!useRectangularApproximation) {
            decisionMessage = "Rectangular approximation is disabled, using initial anchor points directly.\n";
            if (initialFitness < 0.1) {
                decisionMessage += "⚠️ WARNING: Initial fitness is very low (" + initialFitness.toFixed(7) + "). The optimization may not converge effectively without rectangular approximation.\n";
                decisionMessage += "\nThe optimization algorithm requires a reasonably good starting point to work properly. ";
                decisionMessage += "When the initial guess is very poor (fitness < 0.1), the algorithm typically fails to converge.\n\n";
                decisionMessage += "Recommendations:\n";
                decisionMessage += "1. Enable rectangular approximation (checkbox above) to automatically find a good starting point, OR\n";
                decisionMessage += "2. Manually enter better initial anchor point positions that are closer to your actual machine dimensions.\n\n";
                decisionMessage += "Proceeding anyway, but calibration will likely fail...\n";
            }
        } else {
            decisionMessage = "Initial fitness >= 0.1 (already good), skipping rectangular optimization and using initial guess directly.\n";
        }
        messagesBox.value = initialMessage + decisionMessage;
        messagesBox.scrollTop = messagesBox.scrollHeight;
        startingGuess = initialGuess;
    }
    
    messagesBox.value += "Using best start for convergence iterations\n";
    messagesBox.scrollTop = messagesBox.scrollHeight;

    function computeGuess() {
        // Clear the canvas
        clearCanvas();

        // Deep copy the starting guess and create a fresh projected measurements copy
        var guessThisTime = JSON.parse(JSON.stringify(startingGuess));
        var measurementsForThisRun = projectMeasurements(JSON.parse(JSON.stringify(rawMeasurements)));

        // Start the optimization - findMaxFitness handles its own output
        findMaxFitness(guessThisTime, measurementsForThisRun);
        
        // Note: findMaxFitness runs asynchronously and will output results when complete
        // The loop continues via the setTimeout inside findMaxFitness's iterate function
    }

    // Start the first optimization run
    computeGuess();
});




//This is where the program really begins. The above is all function definitions
//The way that the progam works is that we basically guess where the four corners are and then
//check to see how good that guess was. To see how good a guess was we "draw" circles from the four corner points
//with radiuses of the measured distances. If the guess was good then all four circles will intersect at a single point.
//The closer the circles are to intersecting at a single point the better the guess is.

//Once we've figured out how good our guess was we try a different guess. We keep the good guesses and throw away the bad guesses
//using a genetic algorithm

//Establish initial guesses for the corners
var initialGuess = {
    tl: {x: 0, y: 2500},
    tr: {x: 3600, y: 2500},
    bl: {x: 0, y: 0},
    br: {x: 3600, y: 0},
    fitness: Infinity  // Initialize to Infinity so any real fitness will be better
}


window.onload = function() {
    let output = document.getElementById('output');
    output.value = "";
    
    // Function to sync input fields with initialGuess
    // Note: BLX, BLY, and BRY are fixed at 0 and have no input fields
    function syncInputFields() {
        document.getElementById('tlx-input').value = initialGuess.tl.x.toFixed(1);
        document.getElementById('tly-input').value = initialGuess.tl.y.toFixed(1);
        document.getElementById('trx-input').value = initialGuess.tr.x.toFixed(1);
        document.getElementById('try-input').value = initialGuess.tr.y.toFixed(1);
        document.getElementById('brx-input').value = initialGuess.br.x.toFixed(1);
    }
    
    // Initialize input fields with current values
    syncInputFields();
    
    // Add event handler for the parse button
    document.getElementById('parse-data-button').addEventListener('click', function() {
        const input = document.getElementById('calibration-input');
        const statusSpan = document.getElementById('parse-status');
        
        if (!input.value.trim()) {
            statusSpan.textContent = 'Please enter calibration data';
            statusSpan.style.color = 'red';
            return;
        }
        
        try {
            const parsedMeasurements = parseCalibrationData(input.value);
            
            // Update the raw measurements
            rawMeasurements = parsedMeasurements;
            
            // Update the global measurements variable with projection
            measurements = projectMeasurements(JSON.parse(JSON.stringify(rawMeasurements)));
            
            statusSpan.textContent = `✓ Parsed ${parsedMeasurements.length} measurements successfully!`;
            statusSpan.style.color = 'green';
            
            // Clear output and canvas, then recompute with new data
            output.value = "";
            clearCanvas();
            computeLinesFitness(measurements, initialGuess);
            
        } catch (error) {
            statusSpan.textContent = '✗ ' + error.message;
            statusSpan.style.color = 'red';
        }
    });
    
    // Add event handler for the apply adjustments button
    document.getElementById('apply-adjustments-button').addEventListener('click', function() {
        const statusSpan = document.getElementById('adjustments-status');
        
        try {
            // Check if measurements have been loaded
            if (!rawMeasurements || rawMeasurements.length === 0) {
                statusSpan.textContent = '✗ Please load measurement data first';
                statusSpan.style.color = 'red';
                return;
            }
            
            // Read scale and offset values from input fields
            const scale = parseFloat(document.getElementById('scale-input').value);
            const offset = parseFloat(document.getElementById('offset-input').value);
            
            // Validate that the values are numbers
            if (isNaN(scale)) {
                statusSpan.textContent = '✗ Scale factor must be a valid number';
                statusSpan.style.color = 'red';
                return;
            }
            
            if (isNaN(offset)) {
                statusSpan.textContent = '✗ Offset must be a valid number';
                statusSpan.style.color = 'red';
                return;
            }
            
            // Validate scale is positive
            if (scale <= 0) {
                statusSpan.textContent = '✗ Scale factor must be positive';
                statusSpan.style.color = 'red';
                return;
            }
            
            // Start with a fresh copy of raw measurements
            let adjustedMeasurements = JSON.parse(JSON.stringify(rawMeasurements));
            
            // Apply scale (unconditionally to avoid floating-point comparison issues)
            adjustedMeasurements = scaleMeasurements(adjustedMeasurements, scale);
            
            // Apply offset (unconditionally to avoid floating-point comparison issues)
            adjustedMeasurements = offsetMeasurements(adjustedMeasurements, offset);
            
            // Apply projection
            measurements = projectMeasurements(adjustedMeasurements);
            
            statusSpan.textContent = `✓ Adjustments applied! Scale: ${scale}, Offset: ${offset}mm`;
            statusSpan.style.color = 'green';
            
            // Clear output and canvas, then recompute with adjusted data
            output.value = "";
            clearCanvas();
            computeLinesFitness(measurements, initialGuess);
            
        } catch (error) {
            statusSpan.textContent = '✗ ' + error.message;
            statusSpan.style.color = 'red';
        }
    });
    
    // Add event handler for the apply anchor positions button
    document.getElementById('apply-anchor-button').addEventListener('click', function() {
        const statusSpan = document.getElementById('anchor-status');
        
        try {
            // Read values from input fields
            const tlx = parseFloat(document.getElementById('tlx-input').value);
            const tly = parseFloat(document.getElementById('tly-input').value);
            const trx = parseFloat(document.getElementById('trx-input').value);
            const tryVal = parseFloat(document.getElementById('try-input').value);
            const brx = parseFloat(document.getElementById('brx-input').value);
            
            // Note: BLX, BLY, and BRY are fixed at 0 (bottom-left origin)
            const blx = 0;
            const bly = 0;
            const bry = 0;
            
            // Validate that all values are numbers
            if (isNaN(tlx) || isNaN(tly) || isNaN(trx) || isNaN(tryVal) || isNaN(brx)) {
                statusSpan.textContent = '✗ All fields must contain valid numbers';
                statusSpan.style.color = 'red';
                return;
            }
            
            // Update the initialGuess object
            initialGuess.tl.x = tlx;
            initialGuess.tl.y = tly;
            initialGuess.tr.x = trx;
            initialGuess.tr.y = tryVal;
            initialGuess.bl.x = blx;
            initialGuess.bl.y = bly;
            initialGuess.br.x = brx;
            initialGuess.br.y = bry;
            initialGuess.fitness = Infinity;  // Initialize to Infinity so any real fitness will be better
            
            statusSpan.textContent = '✓ Anchor positions applied successfully!';
            statusSpan.style.color = 'green';
            
            // Clear output and canvas, then recompute with new positions
            output.value = "";
            clearCanvas();
            computeLinesFitness(measurements, initialGuess);
            
        } catch (error) {
            statusSpan.textContent = '✗ ' + error.message;
            statusSpan.style.color = 'red';
        }
    });
    
    // Add event handler for the randomize anchor positions button
    document.getElementById('randomize-anchor-button').addEventListener('click', function() {
        const statusSpan = document.getElementById('anchor-status');
        
        try {
            // Define reasonable bounds for randomization
            // Width range: 2000mm to 5000mm (reasonable CNC machine sizes)
            // Height range: 1500mm to 3500mm
            const minWidth = 2000;
            const maxWidth = 5000;
            const minHeight = 1500;
            const maxHeight = 3500;
            
            // Generate random dimensions
            const randomWidth = minWidth + Math.random() * (maxWidth - minWidth);
            const randomHeight = minHeight + Math.random() * (maxHeight - minHeight);
            
            // Note: BLX, BLY, and BRY are fixed at 0 (bottom-left origin)
            const blx = 0;
            const bly = 0;
            const bry = 0;
            
            // Set other corners based on random dimensions with slight variations
            const tlx = blx + (Math.random() * 40 - 20); // Small variation around 0
            const tly = randomHeight;
            const trx = randomWidth;
            const tryVal = randomHeight + (Math.random() * 40 - 20); // Small variation
            const brx = randomWidth + (Math.random() * 40 - 20); // Small variation
            
            // Update input fields (only for editable fields)
            document.getElementById('tlx-input').value = tlx.toFixed(1);
            document.getElementById('tly-input').value = tly.toFixed(1);
            document.getElementById('trx-input').value = trx.toFixed(1);
            document.getElementById('try-input').value = tryVal.toFixed(1);
            document.getElementById('brx-input').value = brx.toFixed(1);
            
            // Update the initialGuess object
            initialGuess.tl.x = tlx;
            initialGuess.tl.y = tly;
            initialGuess.tr.x = trx;
            initialGuess.tr.y = tryVal;
            initialGuess.bl.x = blx;
            initialGuess.bl.y = bly;
            initialGuess.br.x = brx;
            initialGuess.br.y = bry;
            initialGuess.fitness = Infinity;  // Initialize to Infinity so any real fitness will be better
            
            statusSpan.textContent = '✓ Positions randomized successfully!';
            statusSpan.style.color = 'green';
            
            // Clear output and canvas, then recompute with new positions
            output.value = "";
            clearCanvas();
            computeLinesFitness(measurements, initialGuess);
            
        } catch (error) {
            statusSpan.textContent = '✗ ' + error.message;
            statusSpan.style.color = 'red';
        }
    });
}

const centerX = initialWidth/2;
const centerY = initialHeight/2;

calculateTensions(centerX, centerY, initialGuess);


//Function to parse calibration data from text input
function parseCalibrationData(inputText) {
    try {
        // Remove any leading/trailing whitespace
        let cleanText = inputText.trim();
        
        // Remove optional square brackets
        cleanText = cleanText.replace(/^\[/, '').replace(/\]$/, '');
        
        // Remove any trailing comma
        cleanText = cleanText.replace(/,$/, '');
        
        // Regex to match measurement objects - handle properties in any order
        const objectRegex = /\{([^}]+)\}/g;
        
        const measurements = [];
        let match;
        
        while ((match = objectRegex.exec(cleanText)) !== null) {
            const objectContent = match[1];
            
            // Extract individual properties using separate regex patterns
            const blMatch = objectContent.match(/bl\s*:\s*([0-9.-]+)/);
            const brMatch = objectContent.match(/br\s*:\s*([0-9.-]+)/);
            const trMatch = objectContent.match(/tr\s*:\s*([0-9.-]+)/);
            const tlMatch = objectContent.match(/tl\s*:\s*([0-9.-]+)/);
            
            // Only add if all four properties are found
            if (blMatch && brMatch && trMatch && tlMatch) {
                measurements.push({
                    bl: parseFloat(blMatch[1]),
                    br: parseFloat(brMatch[1]),
                    tr: parseFloat(trMatch[1]),
                    tl: parseFloat(tlMatch[1])
                });
            }
        }
        
        if (measurements.length === 0) {
            throw new Error('No valid measurements found');
        }
        
        return measurements;
    } catch (error) {
        throw new Error('Failed to parse calibration data: ' + error.message);
    }
}

//Un-comment this code to use the simulated measurements

// const randomMeasurementError = 6;
// const constantMeasurementError = 3;
// var measurements = [];
// measurements.push(takeSimulatedMeasurement(centerX,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY - 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX,centerY - 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY - 400,randomMeasurementError, constantMeasurementError));



// Store the original raw measurements before projection
var rawMeasurements = [{bl:2960.58,   br:3150.08,   tr:3067.72,   tl:3049.85},{bl:3066.96,   br:3042.59,   tr:2957.53,   tl:3158.38},{bl:3167.61,   br:3134.33,   tr:2860.94,   tl:3079.01},{bl:3071.33,   br:3245.05,   tr:2969.86,   tl:2960.50},{bl:2966.88,   br:3356.74,   tr:3090.81,   tl:2843.43},{bl:2859.27,   br:3272.34,   tr:3179.93,   tl:2930.26},];

// Initialize measurements with default projection
var measurements = projectMeasurements(JSON.parse(JSON.stringify(rawMeasurements)));

// computeLinesFitness(measurements, initialGuess);



</script>

</body>
</html>