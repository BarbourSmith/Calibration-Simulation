<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calibration Simulation</title>
    <style>
        body {
            margin: 0;
        }
    </style>
    
</head>
<body id= "mainBody">


See the console.

<script>

const initialWidth = 3000;
const initialHeight = 1800;

const populationSize = 50;
const mutationAmount = 20; //Maximum amount that a single mutation can change a value


//True corners:
//(30, 1820)              (2990,1830)
//
//(0,0)                   (3000, -20)


const measurements = [
{tl: 748.604, tr: 2472.067, bl: 1426.493, br: 2764.56},
{tl: 2372.21, tr: 1149.968, bl: 2436.423, br: 1238.632},
{tl: 2087.219, tr: 1898.011, bl: 1714.555, br: 1452.135}
]

function mutateGene(gene){
    return gene + ((Math.random()*mutationAmount*2) - mutationAmount);
}

function mutate (individual) {
  
  let mutatedIndividual = JSON.parse(JSON.stringify(individual));
  
  mutatedIndividual.tl.x = mutateGene(individual.tl.x);
  mutatedIndividual.tl.y = mutateGene(individual.tl.y);
  
  mutatedIndividual.tr.x = mutateGene(individual.tl.x);
  mutatedIndividual.tr.y = mutateGene(individual.tl.y);
  
  mutatedIndividual.br.x = mutateGene(individual.tl.x);
  mutatedIndividual.br.y = mutateGene(individual.tl.y);
  
  return mutatedIndividual;
}

function findDistanceToArc(px, py, r, ax, ay){
    const i1 = px - ax;
    const i2 = py - ay;
    
    const dist = Math.abs(Math.sqrt((i1*i1)+(i2*i2))-r);
    return dist;
}

//Find the avg dist from xy point to all four arcs
function distPointToArcs(x, y, radiuses, centers){
    
    const tlDist = findDistanceToArc(x, y, radiuses.tl, centers.tl.x, centers.tl.y);
    
    const trDist = findDistanceToArc(x, y, radiuses.tr, centers.tr.x, centers.tr.y);
    
    const blDist = findDistanceToArc(x, y, radiuses.bl, centers.bl.x, centers.bl.y);
    
    const brDist = findDistanceToArc(x, y, radiuses.br, centers.br.x, centers.br.y);
    
    const avg = (tlDist+trDist+blDist+brDist)/4;
    
    return avg;
}

//Walks to the center of the gradient recursively in chunk sizes of individual
function walkClosenessGradient(x, y, stepSize, measurement, individual){
    
    var results = [];
    //Find the minimum point in the set
    
    results.push({
    dist: distPointToArcs(x,y,measurement, individual),
    x: x,
    y: y
    })
    
    results.push({
    dist: distPointToArcs(x,y + stepSize,measurement, individual),
    x: x,
    y: y + stepSize
    })
    
    results.push({
    dist: distPointToArcs(x + stepSize,y + stepSize,measurement, individual),
    x: x + stepSize,
    y: y + stepSize
    })
    
    results.push({
    dist: distPointToArcs(x + stepSize,y,measurement, individual),
    x: x + stepSize,
    y: y
    })
    
    results.push({
    dist: distPointToArcs(x + stepSize,y - stepSize,measurement, individual),
    x: x + stepSize,
    y: y - stepSize
    })
    
    results.push({
    dist: distPointToArcs(x ,y - stepSize,measurement, individual),
    x: x,
    y: y - stepSize
    })
    
    results.push({
    dist: distPointToArcs(x - stepSize,y - stepSize,measurement, individual),
    x: x - stepSize,
    y: y - stepSize
    })
    
    results.push({
    dist: distPointToArcs(x - stepSize,y,measurement, individual),
    x: x - stepSize,
    y: y
    })
    
    results.push({
    dist: distPointToArcs(x - stepSize,y + stepSize,measurement, individual),
    x: x - stepSize,
    y: y + stepSize
    })
    
    //Find the smallest one
    var minDist = results[0].dist;
    var minX    = results[0].x;
    var minY    = results[0].y;
    
    results.forEach(result => {
        if(result.dist < minDist){
            minDist = result.dist;
            minX = result.x;
            minY = result.y;
        }
    })
    
    //If that point is the center return
    if(minX == x && minY == y){
        return {dist: minDist, x: minX, y: minY};
    }
    else{  //Recursively continue walking the gradient
        return walkClosenessGradient(minX, minY, stepSize, measurement, individual);
    }
}

//Returns the point {x: , y: } closest to all four arcs
function findPointClosestToArcs(measurement, individual){
    
    //Walk the gradient with decreasing step size
    var pass1 = walkClosenessGradient(initialWidth/2,initialHeight/2, 100, measurement, individual);
    var pass2 = walkClosenessGradient(pass1.x,pass1.y, 10, measurement, individual);
    var pass3 = walkClosenessGradient(pass2.x,pass2.y, 1, measurement, individual);
    var pass4 = walkClosenessGradient(pass3.x,pass3.y, .1, measurement, individual);
    
    return pass4;
}

function calculateAverage(array) {
    var total = 0;
    var count = 0;

    array.forEach(function(item, index) {
        total += item;
        count++;
    });

    return total / count;
}

function evaluateFitness(individual){
    
    var fitnesses = [];
    
    measurements.forEach(measurement => {
        fitnesses.push(findPointClosestToArcs(measurement, individual).dist);
    });
    
    const fitness = calculateAverage(fitnesses);
    
    individual.fitness = fitness;
}

//Establish initial guesses for the corners
var initialIndividual = {
    tl: {x: 0, y: initialHeight},
    tr: {x: initialWidth, y: initialHeight},
    bl: {x: 0, y: 0},
    br: {x: initialWidth, y: 0},
    fitness: null
    }

console.log("Initial individual: ");
console.log(initialIndividual);

//Build a mutated population
var population = [];

for(let i = 0; i < populationSize; i++){
    population.push(mutate(initialIndividual));
}

//Assign them all fitness functions...smaller is better
population.forEach(individual => {
    evaluateFitness(individual);
});

console.log(population);

//Breed the best

//Repeat until the fitness function is within some threshold



</script>

</body>
</html>