<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calibration Simulation</title>
    <style>
        body {
            margin: 0;
        }
    </style>
    
</head>
<body id= "mainBody">


See the console. It will take a while before you see anything. The program is running in the background.

<div id = "views">

</div>

<script>

//This is the inital guess for how big the machine is. These numbers are wrong intensionally
const initialWidth = 700;
const initialHeight = 400;

//The size of each generation of the population
const populationSize = 50;


//These are the true corners of the machine that we want to solve for
const trueTLX = 0;
const trueTLY = 400;
const trueTRX = 700;
const trueTRY = 400;
const trueBLX = 0;
const trueBLY = 0;
const trueBRX = 700;
const trueBRY = 0;



// const measurements = [
//     {tl: 748.604, tr: 2472.067, bl: 1426.493, br: 2764.56},
//     {tl: 2372.21, tr: 1149.968, bl: 2436.423, br: 1238.632},
//     {tl: 2087.219, tr: 1898.011, bl: 1714.555, br: 1452.135},
//     {tl: 2847.807, tr: 1492.287, bl: 2543.025, br: 658.01},
//     {tl: 1832.44, tr: 2724.18, bl: 846.658, br: 2179.185},
//     {tl: 2068.196, tr: 1496.784, bl: 2043.238, br: 1437.005}
// ]

//This takes in the X and Y cordinates to take a measurement along with the maximum error and
//returns a simulated measurement at that location. X and Y are referenced to the BL corner.
//TODO, make this zero centered. So takeSimulatedMeasurement(0,0...) is in the center of the work area
//TOFIX, This assumes TLY = TRY and generally that the shape is a square which isn't always true
function takeSimulatedMeasurement(x,y,maxError){
    const tl = Math.sqrt((x*x)+(trueTLY-y)*(trueTLY-y)) + ((Math.random()*maxError*2) - maxError);
    const tr = Math.sqrt((trueTRX-x)*(trueTRX-x)+(trueTRY-y)*(trueTRY-y)) + ((Math.random()*maxError*2) - maxError);
    const bl = Math.sqrt((x*x)+(y*y)) + ((Math.random()*maxError*2) - maxError);
    const br = Math.sqrt((trueBRX-x)*(trueBRX-x)+(y*y)) + ((Math.random()*maxError*2) - maxError);
    return {tl: tl, tr: tr, bl: bl, br: br};
}

//Mutates a gene within an individual
function mutateGene(gene, maxMutation){
    const mutatedGene = gene + ((Math.random()*maxMutation*2) - maxMutation);
    return mutatedGene;
}

//Takes an individual and returns a mutated copy
function mutate (individual, maxMutation) {
  
  let mutatedIndividual = JSON.parse(JSON.stringify(individual));
  
  mutatedIndividual.tl.x = mutateGene(individual.tl.x, maxMutation);
  mutatedIndividual.tl.y = mutateGene(individual.tl.y, maxMutation);
  
  mutatedIndividual.tr.x = mutateGene(individual.tr.x, maxMutation);
  mutatedIndividual.tr.y = mutateGene(individual.tr.y, maxMutation);
  
  mutatedIndividual.br.x = mutateGene(individual.br.x, maxMutation);
  mutatedIndividual.br.y = mutateGene(individual.br.y, maxMutation);
  
  return mutatedIndividual;
}

//Finds the shortest distance from (px,py) to a circle centered on (ax, ay) with radius r
function findDistanceToArc(px, py, r, ax, ay){
    const i1 = px - ax;
    const i2 = py - ay;
    
    const dist = Math.abs(Math.sqrt((i1*i1)+(i2*i2))-r);
    return dist;
}

//Find the avg dist from xy point to all four arcs
function distPointToArcs(x, y, radiuses, centers){
    
    const tlDist = findDistanceToArc(x, y, radiuses.tl, centers.tl.x, centers.tl.y);
    
    const trDist = findDistanceToArc(x, y, radiuses.tr, centers.tr.x, centers.tr.y);
    
    const blDist = findDistanceToArc(x, y, radiuses.bl, centers.bl.x, centers.bl.y);
    
    const brDist = findDistanceToArc(x, y, radiuses.br, centers.br.x, centers.br.y);
    
    const avg = (tlDist+trDist+blDist+brDist)/4;
    
    return avg;
}

//Walks to the center of the gradient recursively in chunk sizes of stepSize. Basically what this does is to try 
//the current XY coordinates along with the 8 points in a grid around it and then pick the one which is the best result
function walkClosenessGradient(x, y, stepSize, measurement, individual) {
  var results = [];
  var minDist = Infinity;
  var minX, minY;

  while (true) {
    // Find the minimum point in the set
    results.push({
      dist: distPointToArcs(x, y, measurement, individual),
      x: x,
      y: y
    });

    results.push({
      dist: distPointToArcs(x, y + stepSize, measurement, individual),
      x: x,
      y: y + stepSize
    });

    results.push({
      dist: distPointToArcs(x + stepSize, y + stepSize, measurement, individual),
      x: x + stepSize,
      y: y + stepSize
    });

    results.push({
      dist: distPointToArcs(x + stepSize, y, measurement, individual),
      x: x + stepSize,
      y: y
    });

    results.push({
      dist: distPointToArcs(x + stepSize, y - stepSize, measurement, individual),
      x: x + stepSize,
      y: y - stepSize
    });

    results.push({
      dist: distPointToArcs(x, y - stepSize, measurement, individual),
      x: x,
      y: y - stepSize
    });

    results.push({
      dist: distPointToArcs(x - stepSize, y - stepSize, measurement, individual),
      x: x - stepSize,
      y: y - stepSize
    });

    results.push({
      dist: distPointToArcs(x - stepSize, y, measurement, individual),
      x: x - stepSize,
      y: y
    });

    results.push({
      dist: distPointToArcs(x - stepSize, y + stepSize, measurement, individual),
      x: x - stepSize,
      y: y + stepSize
    });

    // Find the smallest one
    results.forEach(result => {
      if (result.dist < minDist) {
        minDist = result.dist;
        minX = result.x;
        minY = result.y;
      }
    });

    // If that point is the center, return
    if (minX === x && minY === y) {
      return { dist: minDist, x: minX, y: minY };
    }

    // Update x and y to the minimum point
    x = minX;
    y = minY;

    // Clear the results array
    results.length = 0;
  }
}

//Converts from xy to my cordinate frame of reference for viewing. Used only for visualization.
function mq(p){
    const outX = p.x/10;
    const outY = ((p.y*-1)/10)+210;
    return {x: outX, y: outY};
}

//Visualizes the found point and the four arcs...not currently used
//This doesn't work as a part of the whole program because javascript is single threaded and the canvas does not update while
//the program is running. So this function is only useful for debugging
function createView(point, measurement, individual){
    
    var canvas = document.createElement('canvas');
    canvas.id     = "CursorLayer";
    canvas.width  = 400;
    canvas.height = 210;
    canvas.style.border   = "1px solid";
    document.getElementById("views").appendChild(canvas);
    
    var ctx = canvas.getContext("2d");
    
    //Draw in the found point
    const p = mq(point);
    ctx.beginPath();
    ctx.arc(p.x,p.y, 10, 0, 2 * Math.PI, false);
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#003300';
    ctx.stroke();
    
    //Draw in the top left circle
    const tl = mq(individual.tl);
    ctx.beginPath();
    ctx.arc(tl.x,tl.y, measurement.tl/10, 0, 2 * Math.PI, false);
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#003300';
    ctx.stroke();
    
    //Draw in the top right circle
    const tr = mq(individual.tr);
    ctx.beginPath();
    ctx.arc(tr.x,tr.y, measurement.tr/10, 0, 2 * Math.PI, false);
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#003300';
    ctx.stroke();
    
    //Draw in the bottom right circle
    const br = mq(individual.br);
    ctx.beginPath();
    ctx.arc(br.x,br.y, measurement.br/10, 0, 2 * Math.PI, false);
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#003300';
    ctx.stroke();
    
    //Draw in the bottom left circle
    const bl = mq(individual.bl);
    ctx.beginPath();
    ctx.arc(bl.x,bl.y, measurement.bl/10, 0, 2 * Math.PI, false);
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#003300';
    ctx.stroke();
}

//Get the end point of the line given the start point, angle, and length
function getEndPoint(startX, startY, angle, length) {
  var endX = startX + length * Math.cos(angle);
  var endY = startY + length * Math.sin(angle);
  return { x: endX, y: endY };
}

//Compute the distance between two points
function distanceBetweenPoints(a, b, c, d) {
  var dx = c - a;
  var dy = d - b;
  return Math.sqrt(dx * dx + dy * dy);
}

//Computes how close all of the line end points are to eachother
function computeEndpointFitness(line1, line2, line3, line4){

    const a = distanceBetweenPoints(line1.xEnd, line1.yEnd, line2.xEnd, line2.yEnd);
    const b = distanceBetweenPoints(line1.xEnd, line1.yEnd, line3.xEnd, line3.yEnd);
    const c = distanceBetweenPoints(line1.xEnd, line1.yEnd, line4.xEnd, line4.yEnd);
    const d = distanceBetweenPoints(line2.xEnd, line2.yEnd, line3.xEnd, line3.yEnd);
    const e = distanceBetweenPoints(line2.xEnd, line2.yEnd, line4.xEnd, line4.yEnd);
    const f = distanceBetweenPoints(line3.xEnd, line3.yEnd, line4.xEnd, line4.yEnd);

    const fitness = (a+b+c+d+e+f)/6;

    return fitness;
}

//Compute line end point
function computeLineEndPoint(line){
    const end = getEndPoint(line.xBegin, line.yBegin, line.theta, line.length);
    line.xEnd = end.x;
    line.yEnd = end.y;
    return line;
}

//Walk lines sucessively until no change is made
function walkLines(tlLine, trLine, blLine, brLine, stepSize) {
  let changeMade = true;
  let bestFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);

  while (changeMade) {
    changeMade = false;

    const lines = [tlLine, trLine, blLine, brLine];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      for (let direction of [-1, 1]) {
        const newLine = computeLineEndPoint({
          xBegin: line.xBegin,
          yBegin: line.yBegin,
          theta: line.theta + direction * stepSize,
          length: line.length
        });

        const newFitness = computeEndpointFitness(
          i === 0 ? newLine : tlLine,
          i === 1 ? newLine : trLine,
          i === 2 ? newLine : blLine,
          i === 3 ? newLine : brLine
        );

        if (newFitness < bestFitness) {
          lines[i] = newLine;
          bestFitness = newFitness;
          changeMade = true;
        }
      }
    }

    tlLine = lines[0];
    trLine = lines[1];
    blLine = lines[2];
    brLine = lines[3];
  }

  return { tlLine, trLine, blLine, brLine };
}

//Find the points at the end of the lines that are the closest together
function magneticallyAttractedLinesFitness(measurement, individual){

    //Define the four lines with starting points and lengths
    var tlLine = computeLineEndPoint({xBegin: individual.tl.x, yBegin: individual.tl.y, theta: -.3, length: measurement.tl});
    var trLine = computeLineEndPoint({xBegin: individual.tr.x, yBegin: individual.tr.y, theta: 3.5, length: measurement.tr});
    var blLine = computeLineEndPoint({xBegin: individual.bl.x, yBegin: individual.bl.y, theta: .5, length: measurement.bl});
    var brLine = computeLineEndPoint({xBegin: individual.br.x, yBegin: individual.br.y, theta: 2.6, length: measurement.br});

    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .1);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .01);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .0001);

    //Here we need to evolve the lines to be end closer together
    const finalFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);
    console.log("Endpoint fitness: " + finalFitness);

    drawLines(tlLine, trLine, blLine, brLine);

    return finalFitness; //This should also return the lines so that we can use them for later processing
}

function computeLinesFitness(measurements, individual){
    var fitnesses = [];
    
    measurements.forEach(measurement => {
        fitnesses.push(magneticallyAttractedLinesFitness(measurement, individual));
    });
    
    const fitness = calculateAverage(fitnesses);

    //Here is where we need to do the calculation of which line is the most fucked and which direction to move it

    console.log("Average fitness: " + fitness)
    
    individual.fitness = fitness;
}

//Used for blipping y values because the canvas naturally has y at the top
function flipY(y) {
  var canvas = document.getElementById("CursorLayer");
  return canvas.height - y;
}

function drawLines(line1, line2, line3, line4) {

    var canvas = document.getElementById("CursorLayer");
    var ctx = canvas.getContext("2d");

    // Set the stroke color to black
    ctx.strokeStyle = "black";

    // Draw the four lines
    ctx.beginPath();
    ctx.moveTo(line1.xBegin, flipY(line1.yBegin));
    ctx.lineTo(line1.xEnd, flipY(line1.yEnd));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line1.xEnd, flipY(line1.yEnd), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line2.xBegin, flipY(line2.yBegin));
    ctx.lineTo(line2.xEnd, flipY(line2.yEnd));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line2.xEnd, flipY(line2.yEnd), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line3.xBegin, flipY(line3.yBegin));
    ctx.lineTo(line3.xEnd, flipY(line3.yEnd));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line3.xEnd, flipY(line3.yEnd), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line4.xBegin, flipY(line4.yBegin));
    ctx.lineTo(line4.xEnd, flipY(line4.yEnd));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line4.xEnd, flipY(line4.yEnd), 2, 0, 2 * Math.PI);
    ctx.fill();
}

//Returns the point {x: , y: } closest to all four arcs
function findPointClosestToArcs(measurement, individual){
    
    //Walk the gradient with decreasing step size
    var pass1 = walkClosenessGradient(initialWidth/2,initialHeight/2, 100, measurement, individual);
    var pass2 = walkClosenessGradient(pass1.x,pass1.y, 10, measurement, individual);
    var pass3 = walkClosenessGradient(pass2.x,pass2.y, 1, measurement, individual);
    var pass4 = walkClosenessGradient(pass3.x,pass3.y, .1, measurement, individual);
    //var pass5 = walkClosenessGradient(pass4.x,pass4.y, .01, measurement, individual);
    //var pass6 = walkClosenessGradient(pass3.x,pass3.y, .001, measurement, individual);
    
    <!-- createView(pass4, measurement, individual); -->
    
    return pass4;
}

//Takes an array of numbers and returns the average
function calculateAverage(array) {
    var total = 0;
    var count = 0;

    array.forEach(function(item, index) {
        total += Math.abs(item);
        count++;
    });

    return total / count;
}

//Takes an array of numbers and returns the max
function calculateMax(array){
    var max = 0;
    array.forEach(function(item, index) {
        if(item > max){
            max = item;
        }
    });
    return max;
}

//Evaluates the fitness of an individual by finding the average distance to all four arcs
function evaluateFitness(individual){
    
    var fitnesses = [];
    
    measurements.forEach(measurement => {
        fitnesses.push(findPointClosestToArcs(measurement, individual).dist);
    });
    
    const fitness = calculateAverage(fitnesses);
    
    individual.fitness = fitness;
}

//Computes the average fitness of the whole population. Used for printing out progress. Not currently used.
function computeAverageFitness(population){
    var totalFitness = 0;
    var count = 0;
    population.forEach(individual => {
        totalFitness = totalFitness + individual.fitness;
        count = count+1;
    })
    
    return totalFitness/count;
}

//Takes two individuals and breeds them by randomly picking genes from each
function breed(individual1, individual2){
    
    var child = {}
    
    Object.keys(individual1).forEach(key => {
        if(Math.random() > .5){
            child[key] = individual1[key];
        }
        else{
            child[key] = individual2[key];
        }
    })
    
    return child;
}

//Takes an individual and either mutates or breeds it with a random mate
function mutateOrBreed(individual, mates, stepSize){
    //Half the time mutate
    if(Math.random() > .5){
        return mutate(individual, stepSize);
    }
    else{
        return breed(individual, mates[Math.floor(Math.random() * mates.length)])
    }
}

function cullAndBreed(population, stepSize){
    
    //Sort the array by best (lowest) fitness
    population.sort((first, second) => {
        return first.fitness > second.fitness;
    })
    
    //Take out the top 10
    var survivors = population.slice(0, 10);
    
    //Mutate those individuals each 4 times to get more
    var newPopulation = [];
    survivors.forEach(survivor => {
        newPopulation.push(mutateOrBreed(survivor, survivors, stepSize));
        newPopulation.push(mutateOrBreed(survivor, survivors, stepSize));
        newPopulation.push(mutateOrBreed(survivor, survivors, stepSize));
        newPopulation.push(mutateOrBreed(survivor, survivors, stepSize));
    })
    
    //Return the new array
    return survivors.concat(newPopulation);
    
}

function evolve(population, stepSize, targetFitness, timeout){
    
    var i = 0;
    
    while(population[0].fitness > targetFitness){

        //Assign them all fitness functions...smaller is better
        population.forEach(individual => {
            evaluateFitness(individual);
        });
        
        //Breed the best
        population = cullAndBreed(population, stepSize);
        
        
        console.log(population[0].fitness);

        //Repeat until the fitness function is within some threshold or timeout
        
        i++;
        if(i > timeout){
            console.log("Breaking");
            break;
        }
    }
    
    return population;
}

//This is where the program really begins. The above is all function definitions
//The way that the progam works is that we basically guess where the four corners are and then
//check to see how good that guess was. To see how good a guess was we "draw" circles from the four corner points
//with radiuses of the measured distances. If the guess was good then all four circles will intersect at a single point.
//The closer the circles are to intersecting at a single point the better the guess is.

//Once we've figured out how good our guess was we try a different guess. We keep the good guesses and throw away the bad guesses
//using a genetic algorithm

//Establish initial guesses for the corners
var initialIndividual = {
    tl: {x: 0, y: initialHeight+5},
    tr: {x: initialWidth+4, y: initialHeight-1.8},
    bl: {x: 0, y: 0},
    br: {x: initialWidth+60, y: 0},
    fitness: 10000
}

var measurements = [];

const centerX = initialWidth/2;
const centerY = initialHeight/2;

measurements.push(takeSimulatedMeasurement(centerX,centerY,0));
measurements.push(takeSimulatedMeasurement(centerX-200,centerY + 100,0));
measurements.push(takeSimulatedMeasurement(centerX-200,centerY,0));
measurements.push(takeSimulatedMeasurement(centerX-200,centerY - 100,0));
measurements.push(takeSimulatedMeasurement(centerX,centerY + 100,0));
measurements.push(takeSimulatedMeasurement(centerX,centerY - 100,0));
measurements.push(takeSimulatedMeasurement(centerX + 200,centerY + 100,0));
measurements.push(takeSimulatedMeasurement(centerX + 200,centerY,0));
measurements.push(takeSimulatedMeasurement(centerX + 200,centerY - 100,0));


var canvas = document.createElement('canvas');
canvas.id     = "CursorLayer";
canvas.width  = 1000;
canvas.height = 600;
canvas.style.border   = "1px solid";
document.getElementById("views").appendChild(canvas);

//magneticallyAttractedLinesFitness(measurements[1], initialIndividual);
computeLinesFitness(measurements, initialIndividual);

// //Build a mutated population
// var population = [initialIndividual];

// for(let i = 0; i < populationSize - 1; i++){
//     population.push(mutate(initialIndividual, 2));
// }

// population = evolve(population, 5, .25, 200);
// population = evolve(population, .5, .25, 200);
// population = evolve(population, .1, .01, 200);
// population = evolve(population, .01, .01, 20000);

// console.log("Final fittest: ");
// console.log(population[0]);
// //console.log(population);

// if(population[0].fitness < 1){
//     console.log("Calibration success");
// }
// else{
//     console.log("Calibration failure...bad measurements");
// }

// console.log("Final individual error: ");
// const fi = population[0];
// console.log(Math.abs(fi.tl.x- trueTLX));
// console.log(Math.abs(fi.tl.y - trueTLY));
// console.log(Math.abs(fi.tr.x - trueTRX));
// console.log(Math.abs(fi.tr.y - trueTRY));
// console.log(Math.abs(fi.br.x - trueBRX));
// console.log(Math.abs(fi.br.y - trueBRY));



</script>

</body>
</html>