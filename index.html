<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calibration Simulation</title>
    <button id="compute-button">Refine Measurments 1x</button>
    <button id="compute-1k-button">1,000x</button>
    <button id="compute-10k-button">10,000x</button>
    <button id="compute-end-button">End</button>
    <style>
        body {
            margin: 0;
        }
    </style>
    
</head>
<body id= "mainBody">

<---click this button to see the simulation find the corners

<div id = "views">

</div>

<script>

//This is the inital guess for how big the machine is. These numbers are wrong intensionally
const initialWidth = 3048 + 12;
const initialHeight = 2200 - 14;


//These are the true corners of the machine that we want to solve for
const trueTLX = -0.6948090610228441;
const trueTLY = 2131.275233532367;
const trueTRX = 3034.4072793128926;
const trueTRY = 2127.1780972406527;
const trueBLX = 0;
const trueBLY = 0;
const trueBRX = 3034.960970894897;
const trueBRY = 0;



// const measurements = [
//     {tl: 748.604, tr: 2472.067, bl: 1426.493, br: 2764.56},
//     {tl: 2372.21, tr: 1149.968, bl: 2436.423, br: 1238.632},
//     {tl: 2087.219, tr: 1898.011, bl: 1714.555, br: 1452.135},
//     {tl: 2847.807, tr: 1492.287, bl: 2543.025, br: 658.01},
//     {tl: 1832.44, tr: 2724.18, bl: 846.658, br: 2179.185},
//     {tl: 2068.196, tr: 1496.784, bl: 2043.238, br: 1437.005}
// ]

//This takes in the X and Y cordinates to take a measurement along with the maximum error and
//returns a simulated measurement at that location. X and Y are referenced to the BL corner.
function takeSimulatedMeasurement(x,y,randomError, constantError){
    const tl = distanceBetweenPoints(trueTLX, trueTLY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const tr = distanceBetweenPoints(trueTRX, trueTRY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const bl = distanceBetweenPoints(trueBLX, trueBLY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    const br = distanceBetweenPoints(trueBRX, trueBRY, x, y) + ((Math.random()*randomError*2) - randomError) + constantError;
    return {tl: tl, tr: tr, bl: bl, br: br};
}

//Compute the distance between two points
function distanceBetweenPoints(a, b, c, d) {
  var dx = c - a;
  var dy = d - b;
  return Math.sqrt(dx * dx + dy * dy);
}

//Get the end point of the line given the start point, angle, and length
function getEndPoint(startX, startY, angle, length) {
  var endX = startX + length * Math.cos(angle);
  var endY = startY + length * Math.sin(angle);
  return { x: endX, y: endY };
}

//Computes how close all of the line end points are to eachother
function computeEndpointFitness(line1, line2, line3, line4){

    const a = distanceBetweenPoints(line1.xEnd, line1.yEnd, line2.xEnd, line2.yEnd);
    const b = distanceBetweenPoints(line1.xEnd, line1.yEnd, line3.xEnd, line3.yEnd);
    const c = distanceBetweenPoints(line1.xEnd, line1.yEnd, line4.xEnd, line4.yEnd);
    const d = distanceBetweenPoints(line2.xEnd, line2.yEnd, line3.xEnd, line3.yEnd);
    const e = distanceBetweenPoints(line2.xEnd, line2.yEnd, line4.xEnd, line4.yEnd);
    const f = distanceBetweenPoints(line3.xEnd, line3.yEnd, line4.xEnd, line4.yEnd);

    const fitness = (a+b+c+d+e+f)/6;

    return fitness;
}

//Compute line end point. Returns the line with the end point added
function computeLineEndPoint(line){
    const end = getEndPoint(line.xBegin, line.yBegin, line.theta, line.length);
    line.xEnd = end.x;
    line.yEnd = end.y;
    return line;
}

//Walk lines sucessively until no change is made
function walkLines(tlLine, trLine, blLine, brLine, stepSize) {
  let changeMade = true;
  let bestFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);

  while (changeMade) {
    changeMade = false;

    const lines = [tlLine, trLine, blLine, brLine];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      for (let direction of [-1, 1]) {
        const newLine = computeLineEndPoint({
          xBegin: line.xBegin,
          yBegin: line.yBegin,
          theta: line.theta + direction * stepSize,
          length: line.length
        });

        const newFitness = computeEndpointFitness(
          i === 0 ? newLine : tlLine,
          i === 1 ? newLine : trLine,
          i === 2 ? newLine : blLine,
          i === 3 ? newLine : brLine
        );

        if (newFitness < bestFitness) {
          lines[i] = newLine;
          bestFitness = newFitness;
          changeMade = true;
        }
      }
    }

    tlLine = lines[0];
    trLine = lines[1];
    blLine = lines[2];
    brLine = lines[3];
  }

  return { tlLine, trLine, blLine, brLine };
}

//Find the points at the end of the lines that are the closest together
function magneticallyAttractedLinesFitness(measurement, individual){

    //These set the inital conditions for theta. They don't really mater, they just have to kinda point to the middle of the frame.
    if(measurement.tlTheta == undefined){
        measurement.tlTheta = -.3;
    }
    if(measurement.trTheta == undefined){
        measurement.trTheta = 3.5;
    }
    if(measurement.blTheta == undefined){
        measurement.blTheta = .5;
    }
    if(measurement.brTheta == undefined){
        measurement.brTheta = 2.6;
    }


    //Define the four lines with starting points and lengths
    var tlLine = computeLineEndPoint({xBegin: individual.tl.x, yBegin: individual.tl.y, theta: measurement.tlTheta, length: measurement.tl});
    var trLine = computeLineEndPoint({xBegin: individual.tr.x, yBegin: individual.tr.y, theta: measurement.trTheta, length: measurement.tr});
    var blLine = computeLineEndPoint({xBegin: individual.bl.x, yBegin: individual.bl.y, theta: measurement.blTheta, length: measurement.bl});
    var brLine = computeLineEndPoint({xBegin: individual.br.x, yBegin: individual.br.y, theta: measurement.brTheta, length: measurement.br});

    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .1);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .01);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .0001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .00001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .000001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .0000001);
    var {tlLine, trLine, blLine, brLine} = walkLines(tlLine, trLine, blLine, brLine, .00000001);

    measurement.tlTheta = tlLine.theta;
    measurement.trTheta = trLine.theta;
    measurement.blTheta = blLine.theta;
    measurement.brTheta = brLine.theta;

    //Here we need to evolve the lines to be end closer together
    const finalFitness = computeEndpointFitness(tlLine, trLine, blLine, brLine);

    drawLines(tlLine, trLine, blLine, brLine);

    return {fitness: finalFitness, lines: {tlLine: tlLine, trLine: trLine, blLine: blLine, brLine: brLine}};
}

//Computes the distance of one line's end point from the center of mass of the other three lines
function computeDistanceFromCenterOfMass(lineToCompare, line2, line3, line4){

    //Compute the center of mass
    const x = (line2.xEnd + line3.xEnd + line4.xEnd)/3;
    const y = (line2.yEnd + line3.yEnd + line4.yEnd)/3;

    return {x: lineToCompare.xEnd - x, y: lineToCompare.yEnd - y};
}

//Compute the distances from the center of mass for four lines and converts them into the relivant variables that we can tweak
function generateTweaks(lines){
    //We care about the distances for tlX, tlY, trX, trY, brX

    const tlX = computeDistanceFromCenterOfMass(lines.tlLine, lines.trLine, lines.blLine, lines.brLine).x;
    const tlY = computeDistanceFromCenterOfMass(lines.tlLine, lines.trLine, lines.blLine, lines.brLine).y;
    const trX = computeDistanceFromCenterOfMass(lines.trLine, lines.tlLine, lines.blLine, lines.brLine).x;
    const trY = computeDistanceFromCenterOfMass(lines.trLine, lines.tlLine, lines.blLine, lines.brLine).y;
    const brX = computeDistanceFromCenterOfMass(lines.brLine, lines.tlLine, lines.trLine, lines.blLine).x;

    return {tlX: tlX, tly: tlY, trX: trX, trY: trY, brX: brX};
}

//Computes all of the tweaks and summarizes them
function computeFurthestFromCenterOfMass(lines, lastGuess){

    var tlX = 0;
    var tlY = 0;
    var trX = 0;
    var trY = 0;
    var brX = 0;

    lines.forEach(line => {
        const tweaks = generateTweaks(line);
        
        tlX = tlX + tweaks.tlX;
        tlY = tlY + tweaks.tly;
        trX = trX + tweaks.trX;
        trY = trY + tweaks.trY;
        brX = brX + tweaks.brX;

    })

    tlX = tlX/lines.length;
    tlY = tlY/lines.length;
    trX = trX/lines.length;
    trY = trY/lines.length;
    brX = brX/lines.length;

    const maxError = Math.max(
        Math.abs(tlX),
        Math.abs(tlY),
        Math.abs(trX),
        Math.abs(trY),
        Math.abs(brX)
    );


    var divisor = -10;
    if(maxError == Math.abs(tlX)){
        //console.log("Move tlY by: " + tlY/divisor);
        lastGuess.tl.x = lastGuess.tl.x + tlX/divisor;
    }
    if(maxError == Math.abs(tlY)){
        //console.log("Move tlY by: " + tlY/divisor);
        lastGuess.tl.y = lastGuess.tl.y + tlY/divisor;
    }
    else if(maxError == Math.abs(trX)){
        //console.log("Move trX by: " + trX/divisor);
        lastGuess.tr.x = lastGuess.tr.x + trX/divisor;
    }
    else if(maxError == Math.abs(trY)){
        //console.log("Move trY by: " + trY/divisor);
        lastGuess.tr.y = lastGuess.tr.y + trY/divisor;
    }
    else if(maxError == Math.abs(brX)){
        //console.log("Move brX by: " + brX/divisor);
        lastGuess.br.x = lastGuess.br.x + brX/divisor;
    }
    
    return lastGuess;
}

function computeLinesFitness(measurements, lastGuess){
    var fitnesses = [];
    var allLines = [];
    
    //Check each of the measurements against the guess
    measurements.forEach(measurement => {
        const {fitness, lines} = magneticallyAttractedLinesFitness(measurement, lastGuess);
        fitnesses.push(fitness);
        allLines.push(lines);
    });
    
    const fitness = calculateAverage(fitnesses);

    console.log(fitnesses);

    //Here is where we need to do the calculation of which line is the most fucked and which direction to move it
    lastGuess = computeFurthestFromCenterOfMass(allLines, lastGuess);
    lastGuess.fitness = fitness;

    return lastGuess;
}

//Used for blipping y values because the canvas naturally has y at the top
function flipY(y) {
  var canvas = document.getElementById("CursorLayer");
  return canvas.height - y;
}

function drawLines(line1, line2, line3, line4) {
    var canvas = document.getElementById("CursorLayer");
    var ctx = canvas.getContext("2d");

    // Set the stroke color to a lighter grey
    ctx.strokeStyle = "#999";

    // Draw the four lines
    ctx.setLineDash([5, 5]);

    ctx.beginPath();
    ctx.moveTo(line1.xBegin / 4, flipY(line1.yBegin / 4));
    ctx.lineTo(line1.xEnd / 4, flipY(line1.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line1.xEnd / 4, flipY(line1.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line2.xBegin / 4, flipY(line2.yBegin / 4));
    ctx.lineTo(line2.xEnd / 4, flipY(line2.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line2.xEnd / 4, flipY(line2.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line3.xBegin / 4, flipY(line3.yBegin / 4));
    ctx.lineTo(line3.xEnd / 4, flipY(line3.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line3.xEnd / 4, flipY(line3.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(line4.xBegin / 4, flipY(line4.yBegin / 4));
    ctx.lineTo(line4.xEnd / 4, flipY(line4.yEnd / 4));
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(line4.xEnd / 4, flipY(line4.yEnd / 4), 2, 0, 2 * Math.PI);
    ctx.fill();
}



//Takes an array of numbers and returns the average
function calculateAverage(array) {
    var total = 0;
    var count = 0;

    array.forEach(function(item, index) {
        total += Math.abs(item);
        count++;
    });

    return total / count;
}

function printResults(guess){
    console.log("tlX error: " + (guess.tl.x - trueTLX) + "mm at: " + guess.tl.x);
    console.log("tlY error: " + (guess.tl.y - trueTLY) + "mm at: " + guess.tl.y);
    console.log("trX error: " + (guess.tr.x - trueTRX) + "mm at: " + guess.tr.x);
    console.log("trY error: " + (guess.tr.y - trueTRY) + "mm at: " + guess.tr.y);
    console.log("brX error: " + (guess.br.x - trueBRX) + "mm at: " + guess.br.x);

    console.log("(" + guess.tl.x + ", " + guess.tl.y + "), (" + guess.tr.x + ", " + guess.tr.y + ")\n (" + guess.bl.x + ", " + guess.bl.y + "), (" + guess.br.x + ", " + guess.br.y + ")"); 

}

//Projects the measurements to the plane of the machine
function projectMeasurement(measurement){
    const tlZ = 116;
    const trZ = 69;
    const blZ = 47;
    const brZ = 89;

    const tl = Math.sqrt(Math.pow(measurement.tl,2) - Math.pow(tlZ,2));
    const tr = Math.sqrt(Math.pow(measurement.tr,2) - Math.pow(trZ,2));
    const bl = Math.sqrt(Math.pow(measurement.bl,2) - Math.pow(blZ,2));
    const br = Math.sqrt(Math.pow(measurement.br,2) - Math.pow(brZ,2));

    return {tl: tl, tr: tr, bl: bl, br: br};
}

//Projects an array of measurements to the plane of the machine to account for the fact 
//that the start and end point are not in the same plane
function projectMeasurements(measurements){
    var projectedMeasurements = [];

    measurements.forEach(measurement => {
        projectedMeasurements.push(projectMeasurement(measurement));
    });

    return projectedMeasurements;
}

//Adds a constant to each measurement
function offsetMeasurements(measurements, offset) {
    const newMeasurements = measurements.map(measurement => {
        return {
            tl: measurement.tl + offset,
            tr: measurement.tr + offset,
            bl: measurement.bl + offset,
            br: measurement.br + offset
        };
    });

    return newMeasurements;
}

//Scales each measurement by a constant
function scaleMeasurements(measurements, scale) {
    const newMeasurements = measurements.map(measurement => {
        return {
            tl: measurement.tl * scale,
            tr: measurement.tr * scale,
            bl: measurement.bl * scale,
            br: measurement.br * scale
        };
    });

    return newMeasurements;
}

function findMaxFitness(initialIndividual, measurements) {
    var maxFitness = -1;
    var newFitness = 0;
    var stagnantCounter = 0;

    while (stagnantCounter < 14) {
        maxFitness = newFitness;

        var maxFitnessThisRun = 0;
        //Run 1,000 steps
        for (let i = 0; i < 100; i++) {
            clearCanvas();
            initialIndividual = computeLinesFitness(measurements, initialIndividual);
            maxFitnessThisRun = Math.max(1 / initialIndividual.fitness, maxFitnessThisRun);
        }

        newFitness = maxFitnessThisRun;
        console.log("Fitness: " + newFitness);

        if (stagnantCounter > 1) {
            console.log("Stagnant Counter: " + stagnantCounter);
        }

        if (newFitness <= maxFitness) {
            stagnantCounter++;
        } else {
            stagnantCounter = 0;
        }
    }

    console.log("Maxfitness: " + maxFitness);
    console.log("NewFitness: " + newFitness);

    return initialIndividual;
}





var canvas = document.createElement('canvas');
canvas.id     = "CursorLayer";
canvas.width  = 1000;
canvas.height = 600;
canvas.style.border   = "1px solid";
document.getElementById("views").appendChild(canvas);

// Define the clearCanvas function here 
function clearCanvas() {
    const canvas = document.getElementById('CursorLayer');
    const context = canvas.getContext('2d');
    context.clearRect(0, 0, canvas.width, canvas.height);
}

// Attach an event listener to the button
const computeButton = document.getElementById('compute-button');
computeButton.addEventListener('click', () => {
    clearCanvas();
    initialIndividual = computeLinesFitness(measurements, initialIndividual);
    printResults(initialIndividual);
});

const compute1kButton = document.getElementById('compute-1k-button');
compute1kButton.addEventListener('click', () => {
    for(let i = 0; i < 1000; i++){
        clearCanvas();
        initialIndividual = computeLinesFitness(measurements, initialIndividual);
        console.log("Fitness: " + 1/initialIndividual.fitness);
    }
    printResults(initialIndividual);
});

const compute10kButton = document.getElementById('compute-10k-button');
compute10kButton.addEventListener('click', () => {
    for(let i = 0; i < 10000; i++){
        clearCanvas();
        initialIndividual = computeLinesFitness(measurements, initialIndividual);
        console.log("Fitness: " + 1/initialIndividual.fitness);
    }
    printResults(initialIndividual);
});


const computeEndButton = document.getElementById('compute-end-button');
computeEndButton.addEventListener('click', () => {

    var result = findMaxFitness(initialIndividual, measurements);

    printResults(result);
});




//This is where the program really begins. The above is all function definitions
//The way that the progam works is that we basically guess where the four corners are and then
//check to see how good that guess was. To see how good a guess was we "draw" circles from the four corner points
//with radiuses of the measured distances. If the guess was good then all four circles will intersect at a single point.
//The closer the circles are to intersecting at a single point the better the guess is.

//Once we've figured out how good our guess was we try a different guess. We keep the good guesses and throw away the bad guesses
//using a genetic algorithm

//Establish initial guesses for the corners
var initialIndividual = {
    tl: {x: 0, y: initialHeight},
    tr: {x: initialWidth, y: initialHeight},
    bl: {x: 0, y: 0},
    br: {x: initialWidth, y: 0},
    fitness: 0
}



const centerX = initialWidth/2;
const centerY = initialHeight/2;

// const randomMeasurementError = 6;
// const constantMeasurementError = 3;
// var measurements = [];
// measurements.push(takeSimulatedMeasurement(centerX,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX-800,centerY - 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX,centerY - 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY + 400,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY,randomMeasurementError, constantMeasurementError));
// measurements.push(takeSimulatedMeasurement(centerX + 800,centerY - 400,randomMeasurementError, constantMeasurementError));



var measurements = [

{bl:1674.36,   br:2756.33,   tr:2389.01,   tl:963.39},
{bl:1563.26,   br:2691.17,   tr:2426.23,   tl:1048.59},
{bl:1452.23,   br:2627.44,   tr:2467.73,   tl:1143.22},
{bl:1366.57,   br:2581.30,   tr:2505.41,   tl:1221.13},
{bl:1281.32,   br:2537.52,   tr:2546.09,   tl:1303.26},
{bl:1201.04,   br:2497.56,   tr:2590.28,   tl:1387.14},
{bl:1124.22,   br:2460.93,   tr:2637.01,   tl:1473.55},
{bl:1050.84,   br:2428.43,   tr:2687.33,   tl:1561.27},
{bl:979.17,   br:2400.87,   tr:2740.36,   tl:1650.33},
{bl:916.80,   br:2376.28,   tr:2795.37,   tl:1740.31},
{bl:1753.29,   br:2628.50,   tr:2235.84,   tl:1086.12},
{bl:1645.01,   br:2559.54,   tr:2274.78,   tl:1162.47},
{bl:1539.87,   br:2491.79,   tr:2319.25,   tl:1247.92},
{bl:1459.41,   br:2442.77,   tr:2359.14,   tl:1320.42},
{bl:1380.04,   br:2395.45,   tr:2402.65,   tl:1396.37},
{bl:1306.12,   br:2355.62,   tr:2449.17,   tl:1475.18},
{bl:1233.60,   br:2318.19,   tr:2498.90,   tl:1556.38},
{bl:1167.15,   br:2281.99,   tr:2551.78,   tl:1639.74},
{bl:1104.33,   br:2250.89,   tr:2607.35,   tl:1725.03},
{bl:1050.16,   br:2222.05,   tr:2665.62,   tl:1811.61},
{bl:1842.09,   br:2504.47,   tr:2082.05,   tl:1216.67},
{bl:1737.83,   br:2427.95,   tr:2124.78,   tl:1286.97},
{bl:1639.05,   br:2359.30,   tr:2172.72,   tl:1363.52},
{bl:1563.08,   br:2306.23,   tr:2215.13,   tl:1430.66},
{bl:1488.08,   br:2256.52,   tr:2261.14,   tl:1500.66},
{bl:1420.00,   br:2213.33,   tr:2310.69,   tl:1574.32},
{bl:1353.43,   br:2171.83,   tr:2363.33,   tl:1650.74},
{bl:1292.75,   br:2133.92,   tr:2419.38,   tl:1729.39},
{bl:1236.16,   br:2100.64,   tr:2477.72,   tl:1810.80},
{bl:1188.42,   br:2071.63,   tr:2538.86,   tl:1893.14},
{bl:1934.94,   br:2379.94,   tr:1931.35,   tl:1354.99},
{bl:1837.55,   br:2301.20,   tr:1975.86,   tl:1417.58},
{bl:1743.96,   br:2227.68,   tr:2028.34,   tl:1487.72},
{bl:1672.44,   br:2171.88,   tr:2073.38,   tl:1549.61},
{bl:1604.50,   br:2119.95,   tr:2122.53,   tl:1614.74},
{bl:1540.18,   br:2072.23,   tr:2175.38,   tl:1683.09},
{bl:1479.39,   br:2028.62,   tr:2231.21,   tl:1754.86},
{bl:1425.13,   br:1987.69,   tr:2289.99,   tl:1829.08},
{bl:1373.33,   br:1951.70,   tr:2351.91,   tl:1905.60},
{bl:1328.80,   br:1921.33,   tr:2416.19,   tl:1984.30},
{bl:2038.59,   br:2261.85,   tr:1781.49,   tl:1495.99},
{bl:1946.32,   br:2177.33,   tr:1830.52,   tl:1554.48},
{bl:1858.04,   br:2099.86,   tr:1885.65,   tl:1618.12},
{bl:1790.87,   br:2041.82,   tr:1934.45,   tl:1674.74},
{bl:1726.87,   br:1986.16,   tr:1987.18,   tl:1735.76},
{bl:1667.55,   br:1934.10,   tr:2043.29,   tl:1799.84},
{bl:1611.07,   br:1887.69,   tr:2102.65,   tl:1866.78},
{bl:1560.04,   br:1844.81,   tr:2165.19,   tl:1936.59},
{bl:1513.39,   br:1806.68,   tr:2230.32,   tl:2009.22},
{bl:1472.70,   br:1772.97,   tr:2298.18,   tl:2084.12},
{bl:2147.33,   br:2145.83,   tr:1634.28,   tl:1642.57},
{bl:2060.57,   br:2059.94,   tr:1685.21,   tl:1694.08},
{bl:1977.83,   br:1976.33,   tr:1744.98,   tl:1754.07},
{bl:1916.18,   br:1913.69,   tr:1797.46,   tl:1806.45},
{bl:1856.55,   br:1854.85,   tr:1854.36,   tl:1863.16},
{bl:1801.74,   br:1798.87,   tr:1914.35,   tl:1923.03},
{bl:1748.60,   br:1747.61,   tr:1977.63,   tl:1986.31},
{bl:1700.20,   br:1701.51,   tr:2043.72,   tl:2052.33},
{bl:1657.97,   br:1659.07,   tr:2112.64,   tl:2121.14},
{bl:1622.03,   br:1621.01,   tr:2183.96,   tl:2192.09},
{bl:2260.51,   br:2039.14,   tr:1488.75,   tl:1790.17},
{bl:2180.83,   br:1947.47,   tr:1543.70,   tl:1837.97},
{bl:2101.45,   br:1858.81,   tr:1609.52,   tl:1894.81},
{bl:2041.98,   br:1791.30,   tr:1666.23,   tl:1942.39},
{bl:1986.61,   br:1727.37,   tr:1727.26,   tl:1994.80},
{bl:1935.39,   br:1667.28,   tr:1791.74,   tl:2050.92},
{bl:1887.25,   br:1611.94,   tr:1859.12,   tl:2109.94},
{bl:1845.17,   br:1560.18,   tr:1929.26,   tl:2172.33},
{bl:1806.82,   br:1513.08,   tr:2002.13,   tl:2237.45},
{bl:1772.81,   br:1473.06,   tr:2077.34,   tl:2304.63},
{bl:2381.11,   br:1934.87,   tr:1346.32,   tl:1939.95},
{bl:2306.40,   br:1841.50,   tr:1406.19,   tl:1984.85},
{bl:2229.96,   br:1744.95,   tr:1478.59,   tl:2035.64},
{bl:2174.02,   br:1674.97,   tr:1540.66,   tl:2081.20},
{bl:2122.68,   br:1607.03,   tr:1605.91,   tl:2130.07},
{bl:2073.15,   br:1542.40,   tr:1675.15,   tl:2182.58},
{bl:2028.90,   br:1481.20,   tr:1747.14,   tl:2238.40},
{bl:1989.14,   br:1424.39,   tr:1821.82,   tl:2297.23},
{bl:1954.47,   br:1372.58,   tr:1898.58,   tl:2358.82},
{bl:1921.34,   br:1328.99,   tr:1977.84,   tl:2422.81},
{bl:2506.93,   br:1840.19,   tr:1206.96,   tl:2091.10},
{bl:2430.73,   br:1736.29,   tr:1276.95,   tl:2132.76},
{bl:2361.42,   br:1639.16,   tr:1353.83,   tl:2180.44},
{bl:2307.98,   br:1562.23,   tr:1421.45,   tl:2222.76},
{bl:2259.18,   br:1488.69,   tr:1491.92,   tl:2268.81},
{bl:2213.96,   br:1418.46,   tr:1566.37,   tl:2318.16},
{bl:2173.52,   br:1352.99,   tr:1643.27,   tl:2370.40},
{bl:2137.58,   br:1291.29,   tr:1722.07,   tl:2426.10},
{bl:2102.58,   br:1235.99,   tr:1803.36,   tl:2484.55},
{bl:2073.42,   br:1187.09,   tr:1886.46,   tl:2545.37},
{bl:2630.65,   br:1752.95,   tr:1076.26,   tl:2243.55},
{bl:2563.22,   br:1645.48,   tr:1151.09,   tl:2282.23},
{bl:2495.64,   br:1539.31,   tr:1237.96,   tl:2327.00},
{bl:2445.96,   br:1459.06,   tr:1311.07,   tl:2366.57},
{bl:2399.57,   br:1379.63,   tr:1387.31,   tl:2410.10},
{bl:2357.51,   br:1303.01,   tr:1466.76,   tl:2456.25},
{bl:2317.82,   br:1232.29,   tr:1548.62,   tl:2506.02},
{bl:2283.08,   br:1165.84,   tr:1632.22,   tl:2558.85},
{bl:2253.32,   br:1103.66,   tr:1717.65,   tl:2613.69},
{bl:2226.83,   br:1048.45,   tr:1804.72,   tl:2671.44},
{bl:2762.56,   br:1680.79,   tr:950.84,   tl:2397.27},
{bl:2693.64,   br:1563.49,   tr:1038.56,   tl:2433.29},
{bl:2630.79,   br:1453.12,   tr:1132.31,   tl:2475.15},
{bl:2584.26,   br:1366.89,   tr:1211.97,   tl:2512.56},
{bl:2540.51,   br:1283.32,   tr:1294.39,   tl:2553.22},
{bl:2500.88,   br:1200.65,   tr:1378.70,   tl:2597.07},
{bl:2464.47,   br:1124.61,   tr:1465.81,   tl:2644.44},
{bl:2431.59,   br:1049.04,   tr:1553.78,   tl:2694.08},
{bl:2402.89,   br:981.57,   tr:1643.51,   tl:2746.52},
{bl:2378.71,   br:918.68,   tr:1734.06,   tl:2801.92},

];
measurements = projectMeasurements(measurements);

computeLinesFitness(measurements, initialIndividual);



</script>

</body>
</html>